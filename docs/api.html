<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>TheApi.api API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>TheApi.api</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="TheApi.api.TheApi"><code class="flex name class">
<span>class <span class="ident">TheApi</span></span>
<span>(</span><span>downloads_dir: str = 'downloads', quiet: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheApi:
    def __init__(self, downloads_dir: str = &#34;downloads&#34;, quiet: bool = False):
        self.base_urls = {
            &#34;advice&#34;: &#34;https://api.adviceslip.com/advice&#34;,
            &#34;animechan&#34;: &#34;https://animechan.io/api/v1/quotes/random&#34;,
            &#34;avatar&#34;: &#34;https://thedobby.club/api/avatars/random/&#34;,
            &#34;btc_value&#34;: &#34;https://api.stakdek.de/api/btc/&#34;,
            &#34;bing_image&#34;: &#34;https://www.bing.com/images/async&#34;,
            &#34;carbon&#34;: &#34;https://carbonara.solopov.dev/api/cook&#34;,
            &#34;cat&#34;: &#34;https://api.thecatapi.com/v1/images/search&#34;,
            &#34;dog&#34;: &#34;https://random.dog/woof.json&#34;,
            &#34;domain&#34;: &#34;https://api.domainsdb.info/v1/domains/search?domain={domain}&amp;zone={zone}&#34;,
            &#34;faker&#34;: &#34;https://fakerapi.it/api/v2/&#34;,
            &#34;fox&#34;: &#34;https://randomfox.ca/floof/&#34;,
            &#34;font&#34;: &#34;https://github.com/google/fonts/raw/main/ofl/poetsenone/PoetsenOne-Regular.ttf&#34;,
            &#34;hindi_jokes&#34;: &#34;https://hindi-jokes-api.onrender.com/jokes?api_key=93eeccc9d663115eba73839b3cd9&#34;,
            &#34;hindi_quote&#34;: &#34;https://hindi-quotes.vercel.app/random&#34;,
            &#34;image&#34;: &#34;https://graph.org/file/1f8d00177ac2429b101b9.jpg&#34;,
            &#34;jokes&#34;: &#34;https://v2.jokeapi.dev/joke/Any&#34;,
            &#34;meme&#34;: &#34;https://meme-api.com/gimme&#34;,
            &#34;neko_url&#34;: &#34;https://nekos.best/api/v2/{endpoint}?amount={amount}&#34;,
            &#34;neko_hug&#34;: &#34;https://nekos.best/api/v2/hug?amount={}&#34;,
            &#34;pdf&#34;: &#34;https://api.stakdek.de/api&#34;,
            &#34;pypi&#34;: &#34;https://pypi.org/pypi&#34;,
            &#34;qr_gen&#34;: &#34;https://api.qrserver.com/v1&#34;,
            &#34;quote&#34;: &#34;https://api.quotable.io/random&#34;,
            &#34;riddle&#34;: &#34;https://riddles-api.vercel.app/random&#34;,
            &#34;useless_fact&#34;: &#34;https://uselessfacts.jsph.pl/api/v2/facts/random&#34;,
            &#34;wikipedia_search&#34;: &#34;https://en.wikipedia.org/w/api.php&#34;,
            &#34;words&#34;: &#34;https://random-word-api.vercel.app/api&#34;,
            &#34;word_info&#34;: &#34;https://api.dictionaryapi.dev/api/v2/entries/en/{word}&#34;,
            &#34;upload&#34;: &#34;https://envs.sh/&#34;,
        }
        self.request = Request()
        self.downloads_dir = downloads_dir
        self.quiet = quiet

        os.makedirs(self.downloads_dir, exist_ok=True)

    def _handle_error(self, error: Exception) -&gt; Union[dict, Exception]:
        if self.quiet:
            return {&#34;error&#34;: True, &#34;message&#34;: str(error)}
        raise error

    async def _create_file(
        self, contents: bytes, ext: str, name: Optional[str] = None
    ) -&gt; str:
        &#34;&#34;&#34;
        Creates a file in the downloads directory, writes the contents to the file, and returns the file path.

        Args:
            contents (bytes): The content to write to the file.
            ext (str): The file extension (e.g., &#39;txt&#39;, &#39;pdf&#39;).
            name (str, optional): The base name for the file. Defaults to None.

        Returns:
            str: The file path where the contents were written.
        &#34;&#34;&#34;
        file_name = f&#34;{name or &#39;file&#39;}_{self._rnd_str()}.{ext}&#34;
        file_path = os.path.join(self.downloads_dir, file_name)

        async with aiofiles.open(file_path, &#34;wb&#34;) as f:
            await f.write(contents)

        return file_path

    def _rnd_str(self) -&gt; str:
        random_str = &#34;&#34;.join(random.choices(string.ascii_letters + string.digits, k=8))
        return random_str

    async def avatar(self):
        &#34;&#34;&#34;
        Fetches a random avatars from the thedobby.club API.

        Returns:
            dict: Contains the file name, file type, and file URL.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;avatar&#34;])

        return response.json()

    async def animechan(self):
        &#34;&#34;&#34;
        Fetches a random anime quote from the AnimeChan API.

        Returns:
            dict: Contains the quote content, anime name, and character details.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;animechan&#34;])
        return response.json()[&#34;data&#34;]

    async def fakerapi(
        self, endpoint: str, quantity: int = 3, locale: str = &#34;en_US&#34;, **kwargs
    ):  # gh-actions Don&#39;t Add it&#39;s example, ignore it.
        &#34;&#34;&#34;
        Fetch data from the FakerAPI using aiohttp.

        Args:
            endpoint (str): The resource endpoint. Valid endpoints are:
                - companies
                - addresses
                - books
                - CreditCards
                - images
                - persons
                - places
                - products
                - texts
                - users

            quantity (int, optional): Number of rows to fetch (default: 3, max: 1000).
            locale (str, optional): Locale for the data (default: &#39;en_US&#39;).  [ See Valid locale ](https://fakerapi.it/#params_locale)

        Raises:
            ValueError: If the locale is invalid, the endpoint is invalid, or the quantity
                is outside the allowed range.

        Returns:
            dict: Response data from the API.
        &#34;&#34;&#34;
        valid_endpoints = [
            &#34;companies&#34;,
            &#34;addresses&#34;,
            &#34;books&#34;,
            &#34;CreditCards&#34;,
            &#34;images&#34;,
            &#34;persons&#34;,
            &#34;places&#34;,
            &#34;products&#34;,
            &#34;texts&#34;,
            &#34;users&#34;,
        ]
        valid_locales = [
            &#34;ar_EG&#34;,
            &#34;ar_JO&#34;,
            &#34;ar_SA&#34;,
            &#34;at_AT&#34;,
            &#34;bg_BG&#34;,
            &#34;bn_BD&#34;,
            &#34;cs_CZ&#34;,
            &#34;da_DK&#34;,
            &#34;de_AT&#34;,
            &#34;de_CH&#34;,
            &#34;de_DE&#34;,
            &#34;el_CY&#34;,
            &#34;el_GR&#34;,
            &#34;en_AU&#34;,
            &#34;en_CA&#34;,
            &#34;en_GB&#34;,
            &#34;en_HK&#34;,
            &#34;en_IN&#34;,
            &#34;en_NG&#34;,
            &#34;en_NZ&#34;,
            &#34;en_PH&#34;,
            &#34;en_SG&#34;,
            &#34;en_UG&#34;,
            &#34;en_US&#34;,
            &#34;en_ZA&#34;,
            &#34;es_AR&#34;,
            &#34;es_ES&#34;,
            &#34;es_PE&#34;,
            &#34;es_VE&#34;,
            &#34;et_EE&#34;,
            &#34;fa_IR&#34;,
            &#34;fi_FI&#34;,
            &#34;fr_BE&#34;,
            &#34;fr_CA&#34;,
            &#34;fr_CH&#34;,
            &#34;fr_FR&#34;,
            &#34;he_IL&#34;,
            &#34;hr_HR&#34;,
            &#34;hu_HU&#34;,
            &#34;hy_AM&#34;,
            &#34;id_ID&#34;,
            &#34;is_IS&#34;,
            &#34;it_CH&#34;,
            &#34;it_IT&#34;,
            &#34;ja_JP&#34;,
            &#34;ka_GE&#34;,
            &#34;kk_KZ&#34;,
            &#34;ko_KR&#34;,
            &#34;lt_LT&#34;,
            &#34;lv_LV&#34;,
            &#34;me_ME&#34;,
            &#34;mn_MN&#34;,
            &#34;ms_MY&#34;,
            &#34;nb_NO&#34;,
            &#34;ne_NP&#34;,
            &#34;nl_BE&#34;,
            &#34;nl_NL&#34;,
            &#34;pl_PL&#34;,
            &#34;pt_BR&#34;,
            &#34;pt_PT&#34;,
            &#34;ro_MD&#34;,
            &#34;ro_RO&#34;,
            &#34;ru_RU&#34;,
            &#34;sk_SK&#34;,
            &#34;sl_SI&#34;,
            &#34;sr_Cyrl_RS&#34;,
            &#34;sr_Latn_RS&#34;,
            &#34;sr_RS&#34;,
            &#34;sv_SE&#34;,
            &#34;th_TH&#34;,
            &#34;tr_TR&#34;,
            &#34;uk_UA&#34;,
            &#34;vi_VN&#34;,
            &#34;zh_CN&#34;,
            &#34;zh_TW&#34;,
        ]

        if locale not in valid_locales:
            return self._handle_error(
                ValueError(
                    f&#34;Invalid locale &#39;{locale}&#39;. Must be one of {&#39; &#39;.join(valid_locales)}&#34;
                )
            )
        if endpoint not in valid_endpoints:
            return self._handle_error(
                ValueError(
                    f&#34;Invalid endpoint &#39;{endpoint}&#39;. Must be one of {&#39; &#39;.join(valid_endpoints)}&#34;
                )
            )
        if quantity &lt; 1 or quantity &gt; 1000:
            return self._handle_error(ValueError(&#34;Quantity must be between 1 and 1000&#34;))

        params = {
            &#34;_quantity&#34;: quantity,
            &#34;_locale&#34;: locale,
            **kwargs,
        }
        url = f&#34;{self.base_urls[&#39;faker&#39;]}{endpoint}&#34;

        result = await self.request.get(url, params=params)
        return result.json()

    async def get_fake_images(
        self,
        quantity: int = 1,
        locale: str = &#34;en_US&#34;,
        type: str = &#34;any&#34;,
        width: int = 640,
        height: int = 480,
    ):
        &#34;&#34;&#34;
        Fetch fake image data from the FakerAPI.

        Args:
            quantity (int, optional): Number of images to fetch (default: 1).
            locale (str, optional): Locale for the images (default: &#34;en_US&#34;), [ See Valid locale ](https://fakerapi.it/#params_locale).
            type (str, optional): Type of image (e.g., &#39;any&#39;, &#39;animals&#39;, &#39;business&#39;, etc.; default: &#34;any&#34;).
            width (int, optional): Width of the images (default: 640).
            height (int, optional): Height of the images (default: 480).

        Returns:
            dict: Response data from the API.
        &#34;&#34;&#34;
        return await self.fakerapi(
            &#34;images&#34;,
            quantity=quantity,
            locale=locale,
            _type=type,
            _width=width,
            _height=height,
        )

    async def get_fake_credit_cards(self, locale: str = &#34;en_US&#34;, quantity: int = 1):
        &#34;&#34;&#34;
        Fetch fake credit card data from the FakerAPI.

        Args:
            locale (str, optional): Locale for the credit card data (default: &#34;en_US&#34;), [ See Valid locale ](https://fakerapi.it/#params_locale).
            amount (int, optional): Number of credit card entries to fetch (default: 1).

        Returns:
            dict: Response data from the API.
        &#34;&#34;&#34;
        return await self.fakerapi(&#34;CreditCards&#34;, quantity=quantity, locale=locale)

    async def get_fake_addresses(self, quantity: int = 1, locale: str = &#34;en_US&#34;):
        &#34;&#34;&#34;
        Fetch fake address data from the FakerAPI.

        Args:
            quantity (int, optional): Number of address entries to fetch (default: 1).
            locale (str, optional): Locale for the address data (default: &#34;en_US&#34;), [ See Valid locale ](https://fakerapi.it/#params_locale).

        Returns:
            dict: Response data from the API.
        &#34;&#34;&#34;
        return await self.fakerapi(&#34;addresses&#34;, quantity=quantity, locale=locale)

    async def get_advice(self):
        &#34;&#34;&#34;
        Fetches a random piece of advice.

        Returns:
            str: A random advice message.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;advice&#34;])
        return response.json()[&#34;slip&#34;][&#34;advice&#34;]

    async def get_btc_value(self, currency: Optional[str] = None) -&gt; dict:
        &#34;&#34;&#34;
        Fetches the current value of Bitcoin (BTC) for the specified currency or all currencies.

        Args:
            currency (str, optional): The currency code (e.g., &#39;eur&#39;, &#39;usd&#39;, &#39;gbp&#39;).
                                      If None, fetches BTC value for all currencies.

        Returns:
            dict: The response containing BTC value(s) for the specified currency or all currencies.

        Raises:
            ValueError: If the provided currency is invalid or the request fails.
        &#34;&#34;&#34;
        valid_currencies = {&#34;eur&#34;, &#34;usd&#34;, &#34;gbp&#34;}
        url = (
            f&#34;{self.base_urls[&#39;btc_value&#39;]}/get_btc_value&#34;
            if not currency
            else f&#34;{self.base_urls[&#39;btc_value&#39;]}/get_btc_{currency.lower()}&#34;
        )

        if currency and currency.lower() not in valid_currencies:
            return self._handle_error(
                ValueError(
                    f&#34;Invalid currency provided: {currency}. Valid options are: {valid_currencies}&#34;
                )
            )

        response = await self.request.get(url)

        return response.json()

    async def get_jokes(self, amount=1):
        &#34;&#34;&#34;
        Fetches a specified number of jokes.

        Args:
            amount (int, optional): The number of jokes to retrieve. Defaults to 1.

        Returns:
            str: A single joke if `amount` is 1.
            list: If `amount` &gt; 1, returns numbered jokes.
        &#34;&#34;&#34;
        url = self.base_urls[&#34;jokes&#34;]
        params = {&#34;type&#34;: &#34;single&#34;, &#34;amount&#34;: amount}
        response = await self.request.get(url, params=params)
        result = response.json()
        if amount == 1:
            return result[&#34;joke&#34;]
        else:
            jokes = [joke[&#34;joke&#34;] for joke in result[&#34;jokes&#34;]]
            return jokes

    async def get_hindi_jokes(self):
        &#34;&#34;&#34;
        Fetches a random Hindi joke.

        Returns:
            str: A random Hindi joke if available, or &#34;No joke found&#34; if not available.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;hindi_jokes&#34;])
        response = response.json()
        return response[&#34;jokeContent&#34;] if response[&#34;status&#34;] else &#34;No joke found.&#34;

    async def generate_pdf(
        self,
        source: str,
        from_url: bool = True,
    ) -&gt; str:  # gh-actions Don&#39;t Add it&#39;s example, ignore it.
        &#34;&#34;&#34;
        Generates a PDF from a URL or an HTML string and saves it to a file.

        Args:
            source (str): The URL of the website (if `from_url=True`) or the HTML string (if `from_url=False`).
            from_url (bool, optional): Whether to generate the PDF from a URL (True) or an HTML string (False).

        Returns:
            FilePath: The file path where the PDF was saved.

        Raises:
            ValueError: If `from_url` is True and `source` is not a valid URL.
        &#34;&#34;&#34;
        if from_url:
            # Validate the URL format using regex
            url_regex = re.compile(
                r&#34;^(https?://)?&#34;  # http or https
                r&#34;(([A-Za-z0-9-]+\.)+[A-Za-z]{2,6})&#34;  # Domain
                r&#34;(:[0-9]{1,5})?&#34;  # Optional port
                r&#34;(/[A-Za-z0-9._%+-]*)*$&#34;,  # Path
                re.IGNORECASE,
            )
            if not re.match(url_regex, source):
                return self._handle_error(ValueError(f&#34;Invalid URL provided: {source}&#34;))
        url = self.base_urls[&#34;pdf&#34;]
        url = url + &#34;/from_url&#34; if from_url else url + &#34;/from_html&#34;
        params = {&#34;url&#34;: source} if from_url else {&#34;html&#34;: source}

        response = await self.request.get(url, params=params)
        pdf_content = response.read()
        file_path = await self._create_file(pdf_content, ext=&#34;pdf&#34;, name=&#34;pdf&#34;)

        return file_path

    async def gen_qr(
        self,
        data: str,
        size: str = &#34;150x150&#34;,
        foreground_color: str = &#34;000000&#34;,
        background_color: str = &#34;FFFFFF&#34;,
    ) -&gt; str:
        &#34;&#34;&#34;
        Generate a QR code using api.qrserver.com and save it as a PNG file.

        Args:
            data (str): The content for the QR code.
            size (str): The size of the QR code in the format &#39;WIDTHxHEIGHT&#39; (default: &#39;150x150&#39;).
            foreground_color (str): The color of the QR code (default: &#39;000000&#39; - black).
            background_color (str): The background color of the QR code (default: &#39;FFFFFF&#39; - white).

        Returns:
            FilePath: The file path where the QR code was saved.
        &#34;&#34;&#34;

        url = f&#34;{self.base_urls[&#39;qr_gen&#39;]}/create-qr-code/&#34;
        params = {
            &#34;size&#34;: size,
            &#34;data&#34;: data,
            &#34;color&#34;: foreground_color,
            &#34;bgcolor&#34;: background_color,
        }
        response = await self.request.get(url=url, params=params)
        file_path = await self._create_file(response.content, ext=&#34;png&#34;, name=&#34;QrCode&#34;)

        return file_path

    async def get_uselessfact(self):
        &#34;&#34;&#34;
        Fetches a random useless fact.

        Returns:
            str: A random useless fact.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;useless_fact&#34;])
        response = response.json()
        return response[&#34;text&#34;]

    async def quote(self) -&gt; str:
        &#34;&#34;&#34;
        Fetches a random quote.

        Returns:
            str: The content of a random quote followed by the author&#39;s name.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;quote&#34;], verify=False)
        data = response.json()
        return f&#34;{data[&#39;content&#39;]}\n\nauthor - {data[&#39;author&#39;]}&#34;

    async def hindi_quote(self) -&gt; str:
        &#34;&#34;&#34;
        Fetches a random Hindi quote.

        Returns:
            str: The content of a random Hindi quote.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;hindi_quote&#34;])
        response = response.json()
        return response[&#34;quote&#34;]

    async def write(self, text):
        &#34;&#34;&#34;
        Creates an image with text written on it, using a predefined template and font,
        and uploads the image after generation.

        Args:
            text (str): The text to be written on the image. Text exceeding 55 characters
                        per line will be wrapped, with up to 25 lines displayed.

        Returns:
            str: The URL of the uploaded image.

        Notes:
            A temporary image file is created, saved, and removed after uploading.
        &#34;&#34;&#34;
        tryimg = &#34;https://graph.org/file/1f8d00177ac2429b101b9.jpg&#34;
        tryresp = await self.request.get(tryimg)
        img = Image.open(BytesIO(tryresp.content))
        draw = ImageDraw.Draw(img)

        font_url = &#34;https://github.com/google/fonts/raw/main/ofl/poetsenone/PoetsenOne-Regular.ttf&#34;
        font_response = await self.request.get(font_url)
        font = ImageFont.truetype(BytesIO(font_response.content), 24)

        x, y = 150, 140
        lines = []
        if len(text) &lt;= 55:
            lines.append(text)
        else:
            all_lines = text.split(&#34;\n&#34;)
            for line in all_lines:
                if len(line) &lt;= 55:
                    lines.append(line)
                else:
                    k = len(line) // 55
                    lines.extend(
                        line[((z - 1) * 55) : (z * 55)] for z in range(1, k + 2)
                    )

        umm = lines[:25]

        line_height = font.getbbox(&#34;hg&#34;)[3]
        linespacing = 41
        for line in umm:
            draw.text((x, y), line, fill=(1, 22, 55), font=font)
            y = y + linespacing

        file_path = os.path.join(self.downloads_dir, f&#34;write_{self._rnd_str()}.jpg&#34;)

        img.save(file_path)

        return file_path

    async def carbon(self, query):
        &#34;&#34;&#34;
        Generates a code snippet image using the Carbon API, saves it to the downloads folder,
        uploads it, and returns the URL of the uploaded image.

        Args:
            query (str): The code snippet to be rendered as an image.

        Returns:
            FilePath: The file path of the saved image.
        &#34;&#34;&#34;
        response = await self.request.post(
            &#34;https://carbonara.solopov.dev/api/cook&#34;,
            json={&#34;code&#34;: query},
            headers={&#34;Content-Type&#34;: &#34;application/json&#34;},
        )
        file_path = await self._create_file(response.content, ext=&#34;png&#34;, name=&#34;carbon&#34;)

        return file_path

    async def wikipedia(self, query):
        &#34;&#34;&#34;
        Searches Wikipedia for a given query and retrieves the top result&#39;s summary, URL, and image.

        Args:
            query (str): The search term to look up on Wikipedia.

        Returns:
            dict: A dictionary containing information about the top search result, with keys:
                - title (str): The title of the Wikipedia article.
                - summary (str): A brief summary of the article&#39;s content.
                - url (str): The URL link to the full Wikipedia article.
                - image_url (str): The URL of the article&#39;s thumbnail image, or &#34;No image available&#34; if none exists.

            If no results are found, returns a dictionary with an &#34;error&#34; key.
        &#34;&#34;&#34;
        search_url = self.base_urls[&#34;wikipedia_search&#34;]

        params = {
            &#34;action&#34;: &#34;query&#34;,
            &#34;list&#34;: &#34;search&#34;,
            &#34;srsearch&#34;: query,
            &#34;format&#34;: &#34;json&#34;,
        }

        search_response = await self.request.get(search_url, params=params)
        search_response = search_response.json()
        search_results = search_response.get(&#34;query&#34;, {}).get(&#34;search&#34;, [])

        if search_results:
            top_result = search_results[0]
            page_id = top_result[&#34;pageid&#34;]
            summary_url = (
                f&#34;{self.base_urls[&#39;wikipedia_search&#39;]}?action=query&amp;prop=extracts|pageimages&#34;
                f&#34;&amp;exintro&amp;explaintext&amp;piprop=thumbnail&amp;pithumbsize=500&amp;format=json&amp;pageids={page_id}&#34;
            )

            summary_response = await self.request.get(summary_url)
            summary_response = summary_response.json()
            pages = summary_response.get(&#34;query&#34;, {}).get(&#34;pages&#34;, {})
            page_info = pages.get(str(page_id), {})
            image_url = page_info.get(&#34;thumbnail&#34;, {}).get(
                &#34;source&#34;, &#34;No image available&#34;
            )

            return {
                &#34;title&#34;: top_result[&#34;title&#34;],
                &#34;summary&#34;: page_info.get(&#34;extract&#34;, &#34;No summary available.&#34;),
                &#34;url&#34;: f&#34;https://en.wikipedia.org/?curid={page_id}&#34;,
                &#34;image_url&#34;: image_url,
            }
        else:
            return self._handle_error(ValueError(&#34;No search results found&#34;))

    async def github_search(self, query, search_type=&#34;repositories&#34;, max_results=3):
        &#34;&#34;&#34;
        Searches GitHub for various types of content.

        Args:
            query (str): The search query.
            search_type (str, optional): The type of search. Can be one of:
                - &#34;repositories&#34;
                - &#34;users&#34;
                - &#34;organizations&#34;
                - &#34;issues&#34;
                - &#34;pull_requests&#34;
                - &#34;commits&#34;
                - &#34;topics&#34;

                Defaults to &#34;repositories&#34;.
            max_results (int, optional): The maximum number of results to return. Defaults to 3.

        Returns:
            list: A list of search results or an error message.
        &#34;&#34;&#34;
        valid_search_types = [
            &#34;repositories&#34;,
            &#34;users&#34;,
            &#34;organizations&#34;,
            &#34;issues&#34;,
            &#34;pull_requests&#34;,
            &#34;commits&#34;,
            &#34;topics&#34;,
        ]

        if search_type not in valid_search_types:
            return {
                &#34;error&#34;: f&#34;Invalid search type. Valid types are: {valid_search_types}&#34;
            }

        url_mapping = {
            &#34;pull_requests&#34;: &#34;https://api.github.com/search/issues&#34;,
            &#34;organizations&#34;: &#34;https://api.github.com/search/users&#34;,
            &#34;topics&#34;: &#34;https://api.github.com/search/topics&#34;,
        }

        if search_type in url_mapping:
            url = url_mapping[search_type]
            if search_type == &#34;pull_requests&#34;:
                query += &#34; type:pr&#34;
            elif search_type == &#34;organizations&#34;:
                query += &#34; type:org&#34;
        else:
            url = f&#34;https://api.github.com/search/{search_type}&#34;

        headers = {&#34;Accept&#34;: &#34;application/vnd.github.v3+json&#34;}
        params = {&#34;q&#34;: query, &#34;per_page&#34;: max_results}

        try:
            response = await self.request.get(url, headers=headers, params=params)
            response = response.json()
            items = response.get(&#34;items&#34;, [])

            result_list = []

            for item in items:
                item_info = {}
                if search_type == &#34;repositories&#34;:
                    item_info = {
                        &#34;name&#34;: item[&#34;name&#34;],
                        &#34;full_name&#34;: item[&#34;full_name&#34;],
                        &#34;description&#34;: item[&#34;description&#34;],
                        &#34;url&#34;: item[&#34;html_url&#34;],
                        &#34;language&#34;: item.get(&#34;language&#34;),
                        &#34;stargazers_count&#34;: item.get(&#34;stargazers_count&#34;),
                        &#34;forks_count&#34;: item.get(&#34;forks_count&#34;),
                    }
                elif search_type in [&#34;users&#34;, &#34;organizations&#34;]:
                    item_info = {
                        &#34;login&#34;: item[&#34;login&#34;],
                        &#34;id&#34;: item[&#34;id&#34;],
                        &#34;url&#34;: item[&#34;html_url&#34;],
                        &#34;avatar_url&#34;: item.get(&#34;avatar_url&#34;),
                        &#34;type&#34;: item.get(&#34;type&#34;),
                        &#34;site_admin&#34;: item.get(&#34;site_admin&#34;),
                        &#34;name&#34;: item.get(&#34;name&#34;),
                        &#34;company&#34;: item.get(&#34;company&#34;),
                        &#34;blog&#34;: item.get(&#34;blog&#34;),
                        &#34;location&#34;: item.get(&#34;location&#34;),
                        &#34;email&#34;: item.get(&#34;email&#34;),
                        &#34;bio&#34;: item.get(&#34;bio&#34;),
                        &#34;public_repos&#34;: item.get(&#34;public_repos&#34;),
                        &#34;public_gists&#34;: item.get(&#34;public_gists&#34;),
                        &#34;followers&#34;: item.get(&#34;followers&#34;),
                        &#34;following&#34;: item.get(&#34;following&#34;),
                    }
                elif search_type in [&#34;issues&#34;, &#34;pull_requests&#34;]:
                    item_info = {
                        &#34;title&#34;: item[&#34;title&#34;],
                        &#34;user&#34;: item[&#34;user&#34;][&#34;login&#34;],
                        &#34;state&#34;: item[&#34;state&#34;],
                        &#34;url&#34;: item[&#34;html_url&#34;],
                        &#34;comments&#34;: item.get(&#34;comments&#34;),
                        &#34;created_at&#34;: item.get(&#34;created_at&#34;),
                        &#34;updated_at&#34;: item.get(&#34;updated_at&#34;),
                        &#34;closed_at&#34;: item.get(&#34;closed_at&#34;),
                    }
                elif search_type == &#34;commits&#34;:
                    item_info = {
                        &#34;sha&#34;: item[&#34;sha&#34;],
                        &#34;commit_message&#34;: item[&#34;commit&#34;][&#34;message&#34;],
                        &#34;author&#34;: item[&#34;commit&#34;][&#34;author&#34;][&#34;name&#34;],
                        &#34;date&#34;: item[&#34;commit&#34;][&#34;author&#34;][&#34;date&#34;],
                        &#34;url&#34;: item[&#34;html_url&#34;],
                    }
                elif search_type == &#34;topics&#34;:
                    item_info = {
                        &#34;name&#34;: item[&#34;name&#34;],
                        &#34;display_name&#34;: item.get(&#34;display_name&#34;),
                        &#34;short_description&#34;: item.get(&#34;short_description&#34;),
                        &#34;description&#34;: item.get(&#34;description&#34;),
                        &#34;created_by&#34;: item.get(&#34;created_by&#34;),
                        &#34;url&#34;: item.get(&#34;url&#34;) if &#34;url&#34; in item else None,
                    }

                result_list.append(item_info)

            return result_list

        except Exception as e:
            return self._handle_error(ValueError(f&#34;Unexpected error: {e}&#34;))

    async def get_words(
        self, words=10, letter=None, word_type=&#34;capitalized&#34;, alphabetize=False
    ):
        &#34;&#34;&#34;
        Fetch random words from the Random Word API.

        Args:
            words (int): Number of words to generate (default is 10).
            letter (str): First letter of the words (optional).
            word_type (str): Type of words (lowercase, uppercase, capitalized; default is capitalized).
            alphabetize (bool): Whether to alphabetize the result (default is False).

        Returns:
            list: A list of random words or an error message.
        &#34;&#34;&#34;
        params = {
            &#34;words&#34;: words,
            &#34;type&#34;: word_type,
            &#34;alphabetize&#34;: str(alphabetize).lower(),
        }
        if letter:
            params[&#34;letter&#34;] = letter

        response = await self.request.get(self.base_urls[&#34;words&#34;], params=params)
        return response.json()

    async def cat(self):
        &#34;&#34;&#34;
        Fetches a random cat image URL.

        Returns:
            str or None: The URL of a random cat image if available; None if no response is received.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;cat&#34;])
        response = response.json()
        return response[0][&#34;url&#34;] if response else None

    async def dog(self):
        &#34;&#34;&#34;
        Fetches a random dog image URL.

        Returns:
            str or None: The URL of a random dog image if available; None if no response is received.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;dog&#34;])
        response = response.json()
        return response[&#34;url&#34;] if response else None

    async def pypi(self, package_name):
        &#34;&#34;&#34;
        Retrieves metadata information about a specified Python package from the PyPI API.

        Args:
            package_name (str): The name of the package to search for on PyPI.

        Returns:
            dict or None: A dictionary with relevant package information if found.
            Returns None if the package is not found or there is an error.
        &#34;&#34;&#34;
        url = f&#34;{self.base_urls[&#39;pypi&#39;]}/{package_name}/json&#34;
        response = await self.request.get(url)
        response = response.json()
        if response:
            return response
        else:
            return None

    async def meme(self):
        &#34;&#34;&#34;
        Fetches a random meme image URL.

        Returns:
            str or None: The URL of the meme image if available, otherwise None.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;meme&#34;])
        response = response.json()
        return response[&#34;preview&#34;][-1] if response else None

    async def fox(self):
        &#34;&#34;&#34;
        Fetches a random fox image URL.

        Returns:
            str or None: The URL of the fox image if available, otherwise None.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;fox&#34;])
        response = response.json()
        return response[&#34;link&#34;] if response else None

    async def bing_image(self, query: str, limit: int = 3):
        &#34;&#34;&#34;
        Searches Bing for images based on a query and retrieves image URLs.

        Args:
            query (str): The search query string for finding images.
            limit (int, optional): The maximum number of image URLs to return. Defaults to 3.

        Returns:
            list: A list of image URLs retrieved from the Bing search results.
        &#34;&#34;&#34;
        data = {
            &#34;q&#34;: query,
            &#34;first&#34;: 0,
            &#34;count&#34;: limit,
            &#34;adlt&#34;: &#34;off&#34;,
            &#34;qft&#34;: &#34;&#34;,
        }
        response = await self.request.get(self.base_urls[&#34;bing_image&#34;], params=data)
        return (
            re.findall(r&#34;murl&amp;quot;:&amp;quot;(.*?)&amp;quot;&#34;, response.text)
            if response
            else []
        )

    async def stackoverflow_search(self, query, max_results=3, sort_type=&#34;relevance&#34;):
        &#34;&#34;&#34;
        Searches Stack Overflow for questions based on a query, returning results sorted by relevance or another specified criteria.

        Args:
            query (str): The search query string.
            max_results (int, optional): The maximum number of results to return. Defaults to 3.
            sort_type (str, optional): The sorting criteria for the results, such as &#34;relevance&#34; or &#34;votes&#34;. Defaults to &#34;relevance&#34;.

        Returns:
            list: A list of search results in JSON format, with each entry containing Stack Overflow question details.

        Raises:
            ValueError: If there is an issue with the request to the Stack Overflow API.
        &#34;&#34;&#34;

        url = &#34;https://api.stackexchange.com/2.3/search/advanced&#34;
        params = {
            &#34;order&#34;: &#34;desc&#34;,
            &#34;sort&#34;: sort_type,
            &#34;q&#34;: query,
            &#34;site&#34;: &#34;stackoverflow&#34;,
            &#34;page&#34;: 1,
        }

        all_results = []
        while len(all_results) &lt; max_results:
            response = await self.request.get(url, params=params)
            response = response.json()
            results = response.get(&#34;items&#34;, [])
            if not results:
                break

            all_results.extend(results)
            if len(results) &lt; 30:
                break

            params[&#34;page&#34;] += 1

        return all_results[:max_results]

    async def blackpink(self, query, color=&#34;#ff94e0&#34;, border_color=None):
        &#34;&#34;&#34;
        Creates a stylized &#34;Blackpink&#34;-themed image with custom text, color, and optional border.
        Args:
            query (str): The text to display on the image.
            color (str, optional): The primary color of the text and gradient background in hex format.
                Defaults to &#34;#ff94e0&#34; (a pink shade).
            border_color (str, optional): The color of the image border in hex format.
                If not provided, defaults to the value of `color`.
        Returns:
            FilePath: The file path of the generated image with delete attribute.
        &#34;&#34;&#34;
        text = query
        font_path = &#34;/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf&#34;
        initial_font_size = 100

        img_width = 800
        img_height = 600

        dummy_img = Image.new(&#34;RGB&#34;, (1, 1))
        draw_dummy = ImageDraw.Draw(dummy_img)

        font_size = initial_font_size
        padding = 50
        max_width = img_width - 2 * padding
        max_height = img_height - 2 * padding

        font = ImageFont.truetype(font_path, font_size)
        lines = textwrap.wrap(text, width=40)

        while True:
            text_height = sum(
                draw_dummy.textbbox((0, 0), line, font=font)[3]
                - draw_dummy.textbbox((0, 0), line, font=font)[1]
                for line in lines
            )
            if text_height &lt;= max_height and all(
                draw_dummy.textbbox((0, 0), line, font=font)[2] &lt;= max_width
                for line in lines
            ):
                break
            font_size -= 1
            font = ImageFont.truetype(font_path, font_size)
            lines = textwrap.wrap(text, width=40)

        gradient = Image.new(&#34;RGB&#34;, (img_width, img_height), color)
        for i in range(img_height):
            r = int(255 - (255 - int(color[1:3], 16)) * (i / img_height))
            g = int(148 - (148 - int(color[3:5], 16)) * (i / img_height))
            b = int(224 - (224 - int(color[5:7], 16)) * (i / img_height))
            ImageDraw.Draw(gradient).line([(0, i), (img_width, i)], fill=(r, g, b))

        img = Image.new(&#34;RGB&#34;, (img_width, img_height), (0, 0, 0))
        draw = ImageDraw.Draw(img)

        y_text = (img_height - text_height) // 2
        for line in lines:
            bbox = draw.textbbox((0, 0), line, font=font)
            line_width = bbox[2] - bbox[0]
            line_height = bbox[3] - bbox[1]
            draw.text(
                ((img_width - line_width) // 2, y_text),
                line,
                fill=color,
                font=font,
                align=&#34;center&#34;,
            )
            y_text += line_height

        border_color = border_color or color
        border_width = 28
        img_with_border = ImageOps.expand(img, border=border_width, fill=border_color)

        final_img = Image.new(
            &#34;RGB&#34;, (img_with_border.width, img_with_border.height), (0, 0, 0)
        )
        final_img.paste(gradient, (0, 0))
        final_img.paste(img_with_border, (0, 0))

        file_path = os.path.join(self.downloads_dir, f&#34;blackpink_{self._rnd_str()}.jpg&#34;)

        final_img.save(file_path, format=&#34;JPEG&#34;)

        return file_path

    async def upload_image(
        self, file_path: Union[str, bytes, BytesIO]
    ) -&gt; str:  # gh-actions Don&#39;t Add it&#39;s example, ignore it.
        &#34;&#34;&#34;
        Uploads an image to https://envs.sh.

        Args:
            file_path (Union[str, bytes, BytesIO]): The image file to upload.
                Can be a file path (str), binary data (bytes), or a BytesIO object.

        Returns:
            str: The URL or confirmation message of the uploaded image if the upload is successful.
                Returns &#34;Unexpected response format&#34; if the response format is not as expected.

        Raises:
            ValueError: If the file is not found, the input type is invalid,
                or the upload request fails.
        &#34;&#34;&#34;
        if isinstance(file_path, str):
            try:
                async with aiofiles.open(file_path, &#34;rb&#34;) as f:
                    image_bytes = await f.read()
            except FileNotFoundError:
                return self._handle_error(
                    ValueError(
                        f&#34;File not found: &#39;{file_path}&#39; - Ensure the file path is correct.&#34;
                    )
                )
        elif isinstance(file_path, bytes) or isinstance(file_path, BytesIO):
            image_bytes = (
                file_path if isinstance(file_path, bytes) else file_path.getvalue()
            )
        else:
            return self._handle_error(
                ValueError(
                    &#34;Invalid input type - Expected a file path (str), binary data (bytes), or BytesIO object.&#34;
                )
            )

        url = self.base_urls[&#34;upload&#34;]
        files = {&#34;file&#34;: image_bytes}

        try:
            response = await self.request.post(url=url, files=files)
            return (
                response.text.strip()
                if isinstance(response, str)
                else &#34;Unexpected response format&#34;
            )
        except ValueError as e:
            return self._handle_error(ValueError(f&#34;Upload failed: {str(e)}&#34;))

    async def riddle(self) -&gt; dict:
        &#34;&#34;&#34;
        Fetches a random riddle from the Riddles API.

        Returns:
            dict: The riddle data in JSON format.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;riddle&#34;])
        return response.json()

    async def hug(self, amount: int = 1) -&gt; list:
        &#34;&#34;&#34;Fetches a specified number hug gif from the Nekos.Best API.

        Args:
            amount (int): The number of neko images to fetch. Defaults to 1.

        Returns:
            list: A list of dictionaries containing information about each fetched neko image or GIF.
                  Each dictionary typically includes:
                  - anime_name (str): The name of the anime.
                  - url (str): The URL of the GIF.
        &#34;&#34;&#34;
        response = await self.request.get(self.base_urls[&#34;neko_hug&#34;].format(amount))

        return response.json()[&#34;results&#34;]

    async def neko(self, endpoint: str = &#34;neko&#34;, amount: int = 3) -&gt; dict:
        &#34;&#34;&#34;Fetches a specified number of neko images or GIFs from the Nekos.Best API.

        Args:
            endpoint (str): The endpoint category to fetch content from. Default is &#34;neko&#34;.
                Valid image endpoints:
                - &#34;husbando&#34;, &#34;kitsune&#34;, &#34;neko&#34;, &#34;waifu&#34;
                Valid GIF endpoints:
                - &#34;baka&#34;, &#34;bite&#34;, &#34;blush&#34;, &#34;bored&#34;, &#34;cry&#34;, &#34;cuddle&#34;, &#34;dance&#34;, &#34;facepalm&#34;,
                  &#34;feed&#34;, &#34;handhold&#34;, &#34;handshake&#34;, &#34;happy&#34;, &#34;highfive&#34;, &#34;hug&#34;, &#34;kick&#34;,
                  &#34;kiss&#34;, &#34;laugh&#34;, &#34;lurk&#34;, &#34;nod&#34;, &#34;nom&#34;, &#34;nope&#34;, &#34;pat&#34;, &#34;peck&#34;, &#34;poke&#34;,
                  &#34;pout&#34;, &#34;punch&#34;, &#34;shoot&#34;, &#34;shrug&#34;, &#34;slap&#34;, &#34;sleep&#34;, &#34;smile&#34;, &#34;smug&#34;,
                  &#34;stare&#34;, &#34;think&#34;, &#34;thumbsup&#34;, &#34;tickle&#34;, &#34;wave&#34;, &#34;wink&#34;, &#34;yawn&#34;, &#34;yeet&#34;
            amount (int): The number of items to fetch. Default is 3.

        Returns:
            dict: A dictionary containing the results of the request. The dictionary has a key `&#34;results&#34;`,
                  which holds a list of items.

        Raises:
            ValueError: If the endpoint is not a valid category.
        &#34;&#34;&#34;
        valid_categories = [
            &#34;husbando&#34;,
            &#34;kitsune&#34;,
            &#34;neko&#34;,
            &#34;waifu&#34;,  # Images
            &#34;baka&#34;,
            &#34;bite&#34;,
            &#34;blush&#34;,
            &#34;bored&#34;,
            &#34;cry&#34;,
            &#34;cuddle&#34;,
            &#34;dance&#34;,
            &#34;facepalm&#34;,
            &#34;feed&#34;,
            &#34;handhold&#34;,
            &#34;handshake&#34;,
            &#34;happy&#34;,
            &#34;highfive&#34;,
            &#34;hug&#34;,
            &#34;kick&#34;,
            &#34;kiss&#34;,
            &#34;laugh&#34;,
            &#34;lurk&#34;,
            &#34;nod&#34;,
            &#34;nom&#34;,
            &#34;nope&#34;,
            &#34;pat&#34;,
            &#34;peck&#34;,
            &#34;poke&#34;,
            &#34;pout&#34;,
            &#34;punch&#34;,
            &#34;shoot&#34;,
            &#34;shrug&#34;,
            &#34;slap&#34;,
            &#34;sleep&#34;,
            &#34;smile&#34;,
            &#34;smug&#34;,
            &#34;stare&#34;,
            &#34;think&#34;,
            &#34;thumbsup&#34;,
            &#34;tickle&#34;,
            &#34;wave&#34;,
            &#34;wink&#34;,
            &#34;yawn&#34;,
            &#34;yeet&#34;,  # GIFs
        ]

        if endpoint not in valid_categories:
            return self._handle_error(
                ValueError(
                    f&#34;Invalid endpoint &#39;{endpoint}&#39;. Must be one of: {&#39;, &#39;.join(valid_categories)}&#34;
                )
            )

        url = self.base_urls[&#34;neko_url&#34;].format(endpoint=endpoint, amount=amount)

        response = await self.request.get(url)

        return response.json()

    async def domain_search(self, domain: str, zone: str = &#34;com&#34;) -&gt; dict:
        &#34;&#34;&#34;Fetches domain information from the DomainsDB API.

        Args:
            domain (str): The domain name to search for (e.g., &#34;facebook&#34;).
            zone (str): The domain zone to search within (e.g., &#34;com&#34;).Default is &#34;com&#34;.

        Returns:
            dict: A dictionary containing the results of the domain search.
        &#34;&#34;&#34;
        url = self.base_urls[&#34;domain&#34;].format(domain=domain, zone=zone)

        response = await self.request.get(url)

        return response.json()

    async def get_word_definitions(self, word: str) -&gt; List[dict]:
        &#34;&#34;&#34;
        Fetch definitions for a word from the Dictionary API.

        Args:
            word (str): The word to fetch definitions for.

        Returns:
            list: A list of dictionaries containing the word definitions.

        Raises:
            ValueError: If the `word` is not provided or the API request fails.
        &#34;&#34;&#34;
        url = self.base_urls[&#34;word_info&#34;].format(word=word)
        response = await self.request.get(url)
        return response.json()</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="TheApi.api.TheApi.animechan"><code class="name flex">
<span>async def <span class="ident">animechan</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def animechan(self):
    &#34;&#34;&#34;
    Fetches a random anime quote from the AnimeChan API.

    Returns:
        dict: Contains the quote content, anime name, and character details.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;animechan&#34;])
    return response.json()[&#34;data&#34;]</code></pre>
</details>
<div class="desc"><p>Fetches a random anime quote from the AnimeChan API.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Contains the quote content, anime name, and character details.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.avatar"><code class="name flex">
<span>async def <span class="ident">avatar</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def avatar(self):
    &#34;&#34;&#34;
    Fetches a random avatars from the thedobby.club API.

    Returns:
        dict: Contains the file name, file type, and file URL.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;avatar&#34;])

    return response.json()</code></pre>
</details>
<div class="desc"><p>Fetches a random avatars from the thedobby.club API.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Contains the file name, file type, and file URL.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.bing_image"><code class="name flex">
<span>async def <span class="ident">bing_image</span></span>(<span>self, query: str, limit: int = 3)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def bing_image(self, query: str, limit: int = 3):
    &#34;&#34;&#34;
    Searches Bing for images based on a query and retrieves image URLs.

    Args:
        query (str): The search query string for finding images.
        limit (int, optional): The maximum number of image URLs to return. Defaults to 3.

    Returns:
        list: A list of image URLs retrieved from the Bing search results.
    &#34;&#34;&#34;
    data = {
        &#34;q&#34;: query,
        &#34;first&#34;: 0,
        &#34;count&#34;: limit,
        &#34;adlt&#34;: &#34;off&#34;,
        &#34;qft&#34;: &#34;&#34;,
    }
    response = await self.request.get(self.base_urls[&#34;bing_image&#34;], params=data)
    return (
        re.findall(r&#34;murl&amp;quot;:&amp;quot;(.*?)&amp;quot;&#34;, response.text)
        if response
        else []
    )</code></pre>
</details>
<div class="desc"><p>Searches Bing for images based on a query and retrieves image URLs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query</code></strong> :&ensp;<code>str</code></dt>
<dd>The search query string for finding images.</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number of image URLs to return. Defaults to 3.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of image URLs retrieved from the Bing search results.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.blackpink"><code class="name flex">
<span>async def <span class="ident">blackpink</span></span>(<span>self, query, color='#ff94e0', border_color=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def blackpink(self, query, color=&#34;#ff94e0&#34;, border_color=None):
    &#34;&#34;&#34;
    Creates a stylized &#34;Blackpink&#34;-themed image with custom text, color, and optional border.
    Args:
        query (str): The text to display on the image.
        color (str, optional): The primary color of the text and gradient background in hex format.
            Defaults to &#34;#ff94e0&#34; (a pink shade).
        border_color (str, optional): The color of the image border in hex format.
            If not provided, defaults to the value of `color`.
    Returns:
        FilePath: The file path of the generated image with delete attribute.
    &#34;&#34;&#34;
    text = query
    font_path = &#34;/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf&#34;
    initial_font_size = 100

    img_width = 800
    img_height = 600

    dummy_img = Image.new(&#34;RGB&#34;, (1, 1))
    draw_dummy = ImageDraw.Draw(dummy_img)

    font_size = initial_font_size
    padding = 50
    max_width = img_width - 2 * padding
    max_height = img_height - 2 * padding

    font = ImageFont.truetype(font_path, font_size)
    lines = textwrap.wrap(text, width=40)

    while True:
        text_height = sum(
            draw_dummy.textbbox((0, 0), line, font=font)[3]
            - draw_dummy.textbbox((0, 0), line, font=font)[1]
            for line in lines
        )
        if text_height &lt;= max_height and all(
            draw_dummy.textbbox((0, 0), line, font=font)[2] &lt;= max_width
            for line in lines
        ):
            break
        font_size -= 1
        font = ImageFont.truetype(font_path, font_size)
        lines = textwrap.wrap(text, width=40)

    gradient = Image.new(&#34;RGB&#34;, (img_width, img_height), color)
    for i in range(img_height):
        r = int(255 - (255 - int(color[1:3], 16)) * (i / img_height))
        g = int(148 - (148 - int(color[3:5], 16)) * (i / img_height))
        b = int(224 - (224 - int(color[5:7], 16)) * (i / img_height))
        ImageDraw.Draw(gradient).line([(0, i), (img_width, i)], fill=(r, g, b))

    img = Image.new(&#34;RGB&#34;, (img_width, img_height), (0, 0, 0))
    draw = ImageDraw.Draw(img)

    y_text = (img_height - text_height) // 2
    for line in lines:
        bbox = draw.textbbox((0, 0), line, font=font)
        line_width = bbox[2] - bbox[0]
        line_height = bbox[3] - bbox[1]
        draw.text(
            ((img_width - line_width) // 2, y_text),
            line,
            fill=color,
            font=font,
            align=&#34;center&#34;,
        )
        y_text += line_height

    border_color = border_color or color
    border_width = 28
    img_with_border = ImageOps.expand(img, border=border_width, fill=border_color)

    final_img = Image.new(
        &#34;RGB&#34;, (img_with_border.width, img_with_border.height), (0, 0, 0)
    )
    final_img.paste(gradient, (0, 0))
    final_img.paste(img_with_border, (0, 0))

    file_path = os.path.join(self.downloads_dir, f&#34;blackpink_{self._rnd_str()}.jpg&#34;)

    final_img.save(file_path, format=&#34;JPEG&#34;)

    return file_path</code></pre>
</details>
<div class="desc"><p>Creates a stylized "Blackpink"-themed image with custom text, color, and optional border.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to display on the image.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The primary color of the text and gradient background in hex format.
Defaults to "#ff94e0" (a pink shade).</dd>
<dt><strong><code>border_color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color of the image border in hex format.
If not provided, defaults to the value of <code>color</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FilePath</code></dt>
<dd>The file path of the generated image with delete attribute.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.carbon"><code class="name flex">
<span>async def <span class="ident">carbon</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def carbon(self, query):
    &#34;&#34;&#34;
    Generates a code snippet image using the Carbon API, saves it to the downloads folder,
    uploads it, and returns the URL of the uploaded image.

    Args:
        query (str): The code snippet to be rendered as an image.

    Returns:
        FilePath: The file path of the saved image.
    &#34;&#34;&#34;
    response = await self.request.post(
        &#34;https://carbonara.solopov.dev/api/cook&#34;,
        json={&#34;code&#34;: query},
        headers={&#34;Content-Type&#34;: &#34;application/json&#34;},
    )
    file_path = await self._create_file(response.content, ext=&#34;png&#34;, name=&#34;carbon&#34;)

    return file_path</code></pre>
</details>
<div class="desc"><p>Generates a code snippet image using the Carbon API, saves it to the downloads folder,
uploads it, and returns the URL of the uploaded image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query</code></strong> :&ensp;<code>str</code></dt>
<dd>The code snippet to be rendered as an image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FilePath</code></dt>
<dd>The file path of the saved image.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.cat"><code class="name flex">
<span>async def <span class="ident">cat</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def cat(self):
    &#34;&#34;&#34;
    Fetches a random cat image URL.

    Returns:
        str or None: The URL of a random cat image if available; None if no response is received.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;cat&#34;])
    response = response.json()
    return response[0][&#34;url&#34;] if response else None</code></pre>
</details>
<div class="desc"><p>Fetches a random cat image URL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>None</code></dt>
<dd>The URL of a random cat image if available; None if no response is received.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.dog"><code class="name flex">
<span>async def <span class="ident">dog</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dog(self):
    &#34;&#34;&#34;
    Fetches a random dog image URL.

    Returns:
        str or None: The URL of a random dog image if available; None if no response is received.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;dog&#34;])
    response = response.json()
    return response[&#34;url&#34;] if response else None</code></pre>
</details>
<div class="desc"><p>Fetches a random dog image URL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>None</code></dt>
<dd>The URL of a random dog image if available; None if no response is received.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.domain_search"><code class="name flex">
<span>async def <span class="ident">domain_search</span></span>(<span>self, domain: str, zone: str = 'com') ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def domain_search(self, domain: str, zone: str = &#34;com&#34;) -&gt; dict:
    &#34;&#34;&#34;Fetches domain information from the DomainsDB API.

    Args:
        domain (str): The domain name to search for (e.g., &#34;facebook&#34;).
        zone (str): The domain zone to search within (e.g., &#34;com&#34;).Default is &#34;com&#34;.

    Returns:
        dict: A dictionary containing the results of the domain search.
    &#34;&#34;&#34;
    url = self.base_urls[&#34;domain&#34;].format(domain=domain, zone=zone)

    response = await self.request.get(url)

    return response.json()</code></pre>
</details>
<div class="desc"><p>Fetches domain information from the DomainsDB API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>domain</code></strong> :&ensp;<code>str</code></dt>
<dd>The domain name to search for (e.g., "facebook").</dd>
<dt><strong><code>zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The domain zone to search within (e.g., "com").Default is "com".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the results of the domain search.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.fakerapi"><code class="name flex">
<span>async def <span class="ident">fakerapi</span></span>(<span>self, endpoint: str, quantity: int = 3, locale: str = 'en_US', **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fakerapi(
    self, endpoint: str, quantity: int = 3, locale: str = &#34;en_US&#34;, **kwargs
):  # gh-actions Don&#39;t Add it&#39;s example, ignore it.
    &#34;&#34;&#34;
    Fetch data from the FakerAPI using aiohttp.

    Args:
        endpoint (str): The resource endpoint. Valid endpoints are:
            - companies
            - addresses
            - books
            - CreditCards
            - images
            - persons
            - places
            - products
            - texts
            - users

        quantity (int, optional): Number of rows to fetch (default: 3, max: 1000).
        locale (str, optional): Locale for the data (default: &#39;en_US&#39;).  [ See Valid locale ](https://fakerapi.it/#params_locale)

    Raises:
        ValueError: If the locale is invalid, the endpoint is invalid, or the quantity
            is outside the allowed range.

    Returns:
        dict: Response data from the API.
    &#34;&#34;&#34;
    valid_endpoints = [
        &#34;companies&#34;,
        &#34;addresses&#34;,
        &#34;books&#34;,
        &#34;CreditCards&#34;,
        &#34;images&#34;,
        &#34;persons&#34;,
        &#34;places&#34;,
        &#34;products&#34;,
        &#34;texts&#34;,
        &#34;users&#34;,
    ]
    valid_locales = [
        &#34;ar_EG&#34;,
        &#34;ar_JO&#34;,
        &#34;ar_SA&#34;,
        &#34;at_AT&#34;,
        &#34;bg_BG&#34;,
        &#34;bn_BD&#34;,
        &#34;cs_CZ&#34;,
        &#34;da_DK&#34;,
        &#34;de_AT&#34;,
        &#34;de_CH&#34;,
        &#34;de_DE&#34;,
        &#34;el_CY&#34;,
        &#34;el_GR&#34;,
        &#34;en_AU&#34;,
        &#34;en_CA&#34;,
        &#34;en_GB&#34;,
        &#34;en_HK&#34;,
        &#34;en_IN&#34;,
        &#34;en_NG&#34;,
        &#34;en_NZ&#34;,
        &#34;en_PH&#34;,
        &#34;en_SG&#34;,
        &#34;en_UG&#34;,
        &#34;en_US&#34;,
        &#34;en_ZA&#34;,
        &#34;es_AR&#34;,
        &#34;es_ES&#34;,
        &#34;es_PE&#34;,
        &#34;es_VE&#34;,
        &#34;et_EE&#34;,
        &#34;fa_IR&#34;,
        &#34;fi_FI&#34;,
        &#34;fr_BE&#34;,
        &#34;fr_CA&#34;,
        &#34;fr_CH&#34;,
        &#34;fr_FR&#34;,
        &#34;he_IL&#34;,
        &#34;hr_HR&#34;,
        &#34;hu_HU&#34;,
        &#34;hy_AM&#34;,
        &#34;id_ID&#34;,
        &#34;is_IS&#34;,
        &#34;it_CH&#34;,
        &#34;it_IT&#34;,
        &#34;ja_JP&#34;,
        &#34;ka_GE&#34;,
        &#34;kk_KZ&#34;,
        &#34;ko_KR&#34;,
        &#34;lt_LT&#34;,
        &#34;lv_LV&#34;,
        &#34;me_ME&#34;,
        &#34;mn_MN&#34;,
        &#34;ms_MY&#34;,
        &#34;nb_NO&#34;,
        &#34;ne_NP&#34;,
        &#34;nl_BE&#34;,
        &#34;nl_NL&#34;,
        &#34;pl_PL&#34;,
        &#34;pt_BR&#34;,
        &#34;pt_PT&#34;,
        &#34;ro_MD&#34;,
        &#34;ro_RO&#34;,
        &#34;ru_RU&#34;,
        &#34;sk_SK&#34;,
        &#34;sl_SI&#34;,
        &#34;sr_Cyrl_RS&#34;,
        &#34;sr_Latn_RS&#34;,
        &#34;sr_RS&#34;,
        &#34;sv_SE&#34;,
        &#34;th_TH&#34;,
        &#34;tr_TR&#34;,
        &#34;uk_UA&#34;,
        &#34;vi_VN&#34;,
        &#34;zh_CN&#34;,
        &#34;zh_TW&#34;,
    ]

    if locale not in valid_locales:
        return self._handle_error(
            ValueError(
                f&#34;Invalid locale &#39;{locale}&#39;. Must be one of {&#39; &#39;.join(valid_locales)}&#34;
            )
        )
    if endpoint not in valid_endpoints:
        return self._handle_error(
            ValueError(
                f&#34;Invalid endpoint &#39;{endpoint}&#39;. Must be one of {&#39; &#39;.join(valid_endpoints)}&#34;
            )
        )
    if quantity &lt; 1 or quantity &gt; 1000:
        return self._handle_error(ValueError(&#34;Quantity must be between 1 and 1000&#34;))

    params = {
        &#34;_quantity&#34;: quantity,
        &#34;_locale&#34;: locale,
        **kwargs,
    }
    url = f&#34;{self.base_urls[&#39;faker&#39;]}{endpoint}&#34;

    result = await self.request.get(url, params=params)
    return result.json()</code></pre>
</details>
<div class="desc"><p>Fetch data from the FakerAPI using aiohttp.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>endpoint</code></strong> :&ensp;<code>str</code></dt>
<dd>The resource endpoint. Valid endpoints are:
- companies
- addresses
- books
- CreditCards
- images
- persons
- places
- products
- texts
- users</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of rows to fetch (default: 3, max: 1000).</dd>
<dt><strong><code>locale</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Locale for the data (default: 'en_US').
<a href="https://fakerapi.it/#params_locale"> See Valid locale </a></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the locale is invalid, the endpoint is invalid, or the quantity
is outside the allowed range.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Response data from the API.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.fox"><code class="name flex">
<span>async def <span class="ident">fox</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fox(self):
    &#34;&#34;&#34;
    Fetches a random fox image URL.

    Returns:
        str or None: The URL of the fox image if available, otherwise None.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;fox&#34;])
    response = response.json()
    return response[&#34;link&#34;] if response else None</code></pre>
</details>
<div class="desc"><p>Fetches a random fox image URL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>None</code></dt>
<dd>The URL of the fox image if available, otherwise None.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.gen_qr"><code class="name flex">
<span>async def <span class="ident">gen_qr</span></span>(<span>self,<br>data: str,<br>size: str = '150x150',<br>foreground_color: str = '000000',<br>background_color: str = 'FFFFFF') ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def gen_qr(
    self,
    data: str,
    size: str = &#34;150x150&#34;,
    foreground_color: str = &#34;000000&#34;,
    background_color: str = &#34;FFFFFF&#34;,
) -&gt; str:
    &#34;&#34;&#34;
    Generate a QR code using api.qrserver.com and save it as a PNG file.

    Args:
        data (str): The content for the QR code.
        size (str): The size of the QR code in the format &#39;WIDTHxHEIGHT&#39; (default: &#39;150x150&#39;).
        foreground_color (str): The color of the QR code (default: &#39;000000&#39; - black).
        background_color (str): The background color of the QR code (default: &#39;FFFFFF&#39; - white).

    Returns:
        FilePath: The file path where the QR code was saved.
    &#34;&#34;&#34;

    url = f&#34;{self.base_urls[&#39;qr_gen&#39;]}/create-qr-code/&#34;
    params = {
        &#34;size&#34;: size,
        &#34;data&#34;: data,
        &#34;color&#34;: foreground_color,
        &#34;bgcolor&#34;: background_color,
    }
    response = await self.request.get(url=url, params=params)
    file_path = await self._create_file(response.content, ext=&#34;png&#34;, name=&#34;QrCode&#34;)

    return file_path</code></pre>
</details>
<div class="desc"><p>Generate a QR code using api.qrserver.com and save it as a PNG file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>The content for the QR code.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>str</code></dt>
<dd>The size of the QR code in the format 'WIDTHxHEIGHT' (default: '150x150').</dd>
<dt><strong><code>foreground_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The color of the QR code (default: '000000' - black).</dd>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The background color of the QR code (default: 'FFFFFF' - white).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FilePath</code></dt>
<dd>The file path where the QR code was saved.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.generate_pdf"><code class="name flex">
<span>async def <span class="ident">generate_pdf</span></span>(<span>self, source: str, from_url: bool = True) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def generate_pdf(
    self,
    source: str,
    from_url: bool = True,
) -&gt; str:  # gh-actions Don&#39;t Add it&#39;s example, ignore it.
    &#34;&#34;&#34;
    Generates a PDF from a URL or an HTML string and saves it to a file.

    Args:
        source (str): The URL of the website (if `from_url=True`) or the HTML string (if `from_url=False`).
        from_url (bool, optional): Whether to generate the PDF from a URL (True) or an HTML string (False).

    Returns:
        FilePath: The file path where the PDF was saved.

    Raises:
        ValueError: If `from_url` is True and `source` is not a valid URL.
    &#34;&#34;&#34;
    if from_url:
        # Validate the URL format using regex
        url_regex = re.compile(
            r&#34;^(https?://)?&#34;  # http or https
            r&#34;(([A-Za-z0-9-]+\.)+[A-Za-z]{2,6})&#34;  # Domain
            r&#34;(:[0-9]{1,5})?&#34;  # Optional port
            r&#34;(/[A-Za-z0-9._%+-]*)*$&#34;,  # Path
            re.IGNORECASE,
        )
        if not re.match(url_regex, source):
            return self._handle_error(ValueError(f&#34;Invalid URL provided: {source}&#34;))
    url = self.base_urls[&#34;pdf&#34;]
    url = url + &#34;/from_url&#34; if from_url else url + &#34;/from_html&#34;
    params = {&#34;url&#34;: source} if from_url else {&#34;html&#34;: source}

    response = await self.request.get(url, params=params)
    pdf_content = response.read()
    file_path = await self._create_file(pdf_content, ext=&#34;pdf&#34;, name=&#34;pdf&#34;)

    return file_path</code></pre>
</details>
<div class="desc"><p>Generates a PDF from a URL or an HTML string and saves it to a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL of the website (if <code>from_url=True</code>) or the HTML string (if <code>from_url=False</code>).</dd>
<dt><strong><code>from_url</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to generate the PDF from a URL (True) or an HTML string (False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FilePath</code></dt>
<dd>The file path where the PDF was saved.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>from_url</code> is True and <code>source</code> is not a valid URL.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.get_advice"><code class="name flex">
<span>async def <span class="ident">get_advice</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_advice(self):
    &#34;&#34;&#34;
    Fetches a random piece of advice.

    Returns:
        str: A random advice message.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;advice&#34;])
    return response.json()[&#34;slip&#34;][&#34;advice&#34;]</code></pre>
</details>
<div class="desc"><p>Fetches a random piece of advice.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A random advice message.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.get_btc_value"><code class="name flex">
<span>async def <span class="ident">get_btc_value</span></span>(<span>self, currency: str | None = None) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_btc_value(self, currency: Optional[str] = None) -&gt; dict:
    &#34;&#34;&#34;
    Fetches the current value of Bitcoin (BTC) for the specified currency or all currencies.

    Args:
        currency (str, optional): The currency code (e.g., &#39;eur&#39;, &#39;usd&#39;, &#39;gbp&#39;).
                                  If None, fetches BTC value for all currencies.

    Returns:
        dict: The response containing BTC value(s) for the specified currency or all currencies.

    Raises:
        ValueError: If the provided currency is invalid or the request fails.
    &#34;&#34;&#34;
    valid_currencies = {&#34;eur&#34;, &#34;usd&#34;, &#34;gbp&#34;}
    url = (
        f&#34;{self.base_urls[&#39;btc_value&#39;]}/get_btc_value&#34;
        if not currency
        else f&#34;{self.base_urls[&#39;btc_value&#39;]}/get_btc_{currency.lower()}&#34;
    )

    if currency and currency.lower() not in valid_currencies:
        return self._handle_error(
            ValueError(
                f&#34;Invalid currency provided: {currency}. Valid options are: {valid_currencies}&#34;
            )
        )

    response = await self.request.get(url)

    return response.json()</code></pre>
</details>
<div class="desc"><p>Fetches the current value of Bitcoin (BTC) for the specified currency or all currencies.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The currency code (e.g., 'eur', 'usd', 'gbp').
If None, fetches BTC value for all currencies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The response containing BTC value(s) for the specified currency or all currencies.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the provided currency is invalid or the request fails.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.get_fake_addresses"><code class="name flex">
<span>async def <span class="ident">get_fake_addresses</span></span>(<span>self, quantity: int = 1, locale: str = 'en_US')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_fake_addresses(self, quantity: int = 1, locale: str = &#34;en_US&#34;):
    &#34;&#34;&#34;
    Fetch fake address data from the FakerAPI.

    Args:
        quantity (int, optional): Number of address entries to fetch (default: 1).
        locale (str, optional): Locale for the address data (default: &#34;en_US&#34;), [ See Valid locale ](https://fakerapi.it/#params_locale).

    Returns:
        dict: Response data from the API.
    &#34;&#34;&#34;
    return await self.fakerapi(&#34;addresses&#34;, quantity=quantity, locale=locale)</code></pre>
</details>
<div class="desc"><p>Fetch fake address data from the FakerAPI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>quantity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of address entries to fetch (default: 1).</dd>
<dt><strong><code>locale</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Locale for the address data (default: "en_US"), <a href="https://fakerapi.it/#params_locale"> See Valid locale </a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Response data from the API.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.get_fake_credit_cards"><code class="name flex">
<span>async def <span class="ident">get_fake_credit_cards</span></span>(<span>self, locale: str = 'en_US', quantity: int = 1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_fake_credit_cards(self, locale: str = &#34;en_US&#34;, quantity: int = 1):
    &#34;&#34;&#34;
    Fetch fake credit card data from the FakerAPI.

    Args:
        locale (str, optional): Locale for the credit card data (default: &#34;en_US&#34;), [ See Valid locale ](https://fakerapi.it/#params_locale).
        amount (int, optional): Number of credit card entries to fetch (default: 1).

    Returns:
        dict: Response data from the API.
    &#34;&#34;&#34;
    return await self.fakerapi(&#34;CreditCards&#34;, quantity=quantity, locale=locale)</code></pre>
</details>
<div class="desc"><p>Fetch fake credit card data from the FakerAPI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>locale</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Locale for the credit card data (default: "en_US"), <a href="https://fakerapi.it/#params_locale"> See Valid locale </a>.</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of credit card entries to fetch (default: 1).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Response data from the API.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.get_fake_images"><code class="name flex">
<span>async def <span class="ident">get_fake_images</span></span>(<span>self,<br>quantity: int = 1,<br>locale: str = 'en_US',<br>type: str = 'any',<br>width: int = 640,<br>height: int = 480)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_fake_images(
    self,
    quantity: int = 1,
    locale: str = &#34;en_US&#34;,
    type: str = &#34;any&#34;,
    width: int = 640,
    height: int = 480,
):
    &#34;&#34;&#34;
    Fetch fake image data from the FakerAPI.

    Args:
        quantity (int, optional): Number of images to fetch (default: 1).
        locale (str, optional): Locale for the images (default: &#34;en_US&#34;), [ See Valid locale ](https://fakerapi.it/#params_locale).
        type (str, optional): Type of image (e.g., &#39;any&#39;, &#39;animals&#39;, &#39;business&#39;, etc.; default: &#34;any&#34;).
        width (int, optional): Width of the images (default: 640).
        height (int, optional): Height of the images (default: 480).

    Returns:
        dict: Response data from the API.
    &#34;&#34;&#34;
    return await self.fakerapi(
        &#34;images&#34;,
        quantity=quantity,
        locale=locale,
        _type=type,
        _width=width,
        _height=height,
    )</code></pre>
</details>
<div class="desc"><p>Fetch fake image data from the FakerAPI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>quantity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of images to fetch (default: 1).</dd>
<dt><strong><code>locale</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Locale for the images (default: "en_US"), <a href="https://fakerapi.it/#params_locale"> See Valid locale </a>.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of image (e.g., 'any', 'animals', 'business', etc.; default: "any").</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Width of the images (default: 640).</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Height of the images (default: 480).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Response data from the API.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.get_hindi_jokes"><code class="name flex">
<span>async def <span class="ident">get_hindi_jokes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_hindi_jokes(self):
    &#34;&#34;&#34;
    Fetches a random Hindi joke.

    Returns:
        str: A random Hindi joke if available, or &#34;No joke found&#34; if not available.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;hindi_jokes&#34;])
    response = response.json()
    return response[&#34;jokeContent&#34;] if response[&#34;status&#34;] else &#34;No joke found.&#34;</code></pre>
</details>
<div class="desc"><p>Fetches a random Hindi joke.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A random Hindi joke if available, or "No joke found" if not available.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.get_jokes"><code class="name flex">
<span>async def <span class="ident">get_jokes</span></span>(<span>self, amount=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_jokes(self, amount=1):
    &#34;&#34;&#34;
    Fetches a specified number of jokes.

    Args:
        amount (int, optional): The number of jokes to retrieve. Defaults to 1.

    Returns:
        str: A single joke if `amount` is 1.
        list: If `amount` &gt; 1, returns numbered jokes.
    &#34;&#34;&#34;
    url = self.base_urls[&#34;jokes&#34;]
    params = {&#34;type&#34;: &#34;single&#34;, &#34;amount&#34;: amount}
    response = await self.request.get(url, params=params)
    result = response.json()
    if amount == 1:
        return result[&#34;joke&#34;]
    else:
        jokes = [joke[&#34;joke&#34;] for joke in result[&#34;jokes&#34;]]
        return jokes</code></pre>
</details>
<div class="desc"><p>Fetches a specified number of jokes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of jokes to retrieve. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A single joke if <code>amount</code> is 1.</dd>
<dt><code>list</code></dt>
<dd>If <code>amount</code> &gt; 1, returns numbered jokes.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.get_uselessfact"><code class="name flex">
<span>async def <span class="ident">get_uselessfact</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_uselessfact(self):
    &#34;&#34;&#34;
    Fetches a random useless fact.

    Returns:
        str: A random useless fact.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;useless_fact&#34;])
    response = response.json()
    return response[&#34;text&#34;]</code></pre>
</details>
<div class="desc"><p>Fetches a random useless fact.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A random useless fact.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.get_word_definitions"><code class="name flex">
<span>async def <span class="ident">get_word_definitions</span></span>(<span>self, word: str) ‑> List[dict]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_word_definitions(self, word: str) -&gt; List[dict]:
    &#34;&#34;&#34;
    Fetch definitions for a word from the Dictionary API.

    Args:
        word (str): The word to fetch definitions for.

    Returns:
        list: A list of dictionaries containing the word definitions.

    Raises:
        ValueError: If the `word` is not provided or the API request fails.
    &#34;&#34;&#34;
    url = self.base_urls[&#34;word_info&#34;].format(word=word)
    response = await self.request.get(url)
    return response.json()</code></pre>
</details>
<div class="desc"><p>Fetch definitions for a word from the Dictionary API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>word</code></strong> :&ensp;<code>str</code></dt>
<dd>The word to fetch definitions for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of dictionaries containing the word definitions.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the <code>word</code> is not provided or the API request fails.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.get_words"><code class="name flex">
<span>async def <span class="ident">get_words</span></span>(<span>self, words=10, letter=None, word_type='capitalized', alphabetize=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_words(
    self, words=10, letter=None, word_type=&#34;capitalized&#34;, alphabetize=False
):
    &#34;&#34;&#34;
    Fetch random words from the Random Word API.

    Args:
        words (int): Number of words to generate (default is 10).
        letter (str): First letter of the words (optional).
        word_type (str): Type of words (lowercase, uppercase, capitalized; default is capitalized).
        alphabetize (bool): Whether to alphabetize the result (default is False).

    Returns:
        list: A list of random words or an error message.
    &#34;&#34;&#34;
    params = {
        &#34;words&#34;: words,
        &#34;type&#34;: word_type,
        &#34;alphabetize&#34;: str(alphabetize).lower(),
    }
    if letter:
        params[&#34;letter&#34;] = letter

    response = await self.request.get(self.base_urls[&#34;words&#34;], params=params)
    return response.json()</code></pre>
</details>
<div class="desc"><p>Fetch random words from the Random Word API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>words</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of words to generate (default is 10).</dd>
<dt><strong><code>letter</code></strong> :&ensp;<code>str</code></dt>
<dd>First letter of the words (optional).</dd>
<dt><strong><code>word_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of words (lowercase, uppercase, capitalized; default is capitalized).</dd>
<dt><strong><code>alphabetize</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to alphabetize the result (default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of random words or an error message.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.github_search"><code class="name flex">
<span>async def <span class="ident">github_search</span></span>(<span>self, query, search_type='repositories', max_results=3)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def github_search(self, query, search_type=&#34;repositories&#34;, max_results=3):
    &#34;&#34;&#34;
    Searches GitHub for various types of content.

    Args:
        query (str): The search query.
        search_type (str, optional): The type of search. Can be one of:
            - &#34;repositories&#34;
            - &#34;users&#34;
            - &#34;organizations&#34;
            - &#34;issues&#34;
            - &#34;pull_requests&#34;
            - &#34;commits&#34;
            - &#34;topics&#34;

            Defaults to &#34;repositories&#34;.
        max_results (int, optional): The maximum number of results to return. Defaults to 3.

    Returns:
        list: A list of search results or an error message.
    &#34;&#34;&#34;
    valid_search_types = [
        &#34;repositories&#34;,
        &#34;users&#34;,
        &#34;organizations&#34;,
        &#34;issues&#34;,
        &#34;pull_requests&#34;,
        &#34;commits&#34;,
        &#34;topics&#34;,
    ]

    if search_type not in valid_search_types:
        return {
            &#34;error&#34;: f&#34;Invalid search type. Valid types are: {valid_search_types}&#34;
        }

    url_mapping = {
        &#34;pull_requests&#34;: &#34;https://api.github.com/search/issues&#34;,
        &#34;organizations&#34;: &#34;https://api.github.com/search/users&#34;,
        &#34;topics&#34;: &#34;https://api.github.com/search/topics&#34;,
    }

    if search_type in url_mapping:
        url = url_mapping[search_type]
        if search_type == &#34;pull_requests&#34;:
            query += &#34; type:pr&#34;
        elif search_type == &#34;organizations&#34;:
            query += &#34; type:org&#34;
    else:
        url = f&#34;https://api.github.com/search/{search_type}&#34;

    headers = {&#34;Accept&#34;: &#34;application/vnd.github.v3+json&#34;}
    params = {&#34;q&#34;: query, &#34;per_page&#34;: max_results}

    try:
        response = await self.request.get(url, headers=headers, params=params)
        response = response.json()
        items = response.get(&#34;items&#34;, [])

        result_list = []

        for item in items:
            item_info = {}
            if search_type == &#34;repositories&#34;:
                item_info = {
                    &#34;name&#34;: item[&#34;name&#34;],
                    &#34;full_name&#34;: item[&#34;full_name&#34;],
                    &#34;description&#34;: item[&#34;description&#34;],
                    &#34;url&#34;: item[&#34;html_url&#34;],
                    &#34;language&#34;: item.get(&#34;language&#34;),
                    &#34;stargazers_count&#34;: item.get(&#34;stargazers_count&#34;),
                    &#34;forks_count&#34;: item.get(&#34;forks_count&#34;),
                }
            elif search_type in [&#34;users&#34;, &#34;organizations&#34;]:
                item_info = {
                    &#34;login&#34;: item[&#34;login&#34;],
                    &#34;id&#34;: item[&#34;id&#34;],
                    &#34;url&#34;: item[&#34;html_url&#34;],
                    &#34;avatar_url&#34;: item.get(&#34;avatar_url&#34;),
                    &#34;type&#34;: item.get(&#34;type&#34;),
                    &#34;site_admin&#34;: item.get(&#34;site_admin&#34;),
                    &#34;name&#34;: item.get(&#34;name&#34;),
                    &#34;company&#34;: item.get(&#34;company&#34;),
                    &#34;blog&#34;: item.get(&#34;blog&#34;),
                    &#34;location&#34;: item.get(&#34;location&#34;),
                    &#34;email&#34;: item.get(&#34;email&#34;),
                    &#34;bio&#34;: item.get(&#34;bio&#34;),
                    &#34;public_repos&#34;: item.get(&#34;public_repos&#34;),
                    &#34;public_gists&#34;: item.get(&#34;public_gists&#34;),
                    &#34;followers&#34;: item.get(&#34;followers&#34;),
                    &#34;following&#34;: item.get(&#34;following&#34;),
                }
            elif search_type in [&#34;issues&#34;, &#34;pull_requests&#34;]:
                item_info = {
                    &#34;title&#34;: item[&#34;title&#34;],
                    &#34;user&#34;: item[&#34;user&#34;][&#34;login&#34;],
                    &#34;state&#34;: item[&#34;state&#34;],
                    &#34;url&#34;: item[&#34;html_url&#34;],
                    &#34;comments&#34;: item.get(&#34;comments&#34;),
                    &#34;created_at&#34;: item.get(&#34;created_at&#34;),
                    &#34;updated_at&#34;: item.get(&#34;updated_at&#34;),
                    &#34;closed_at&#34;: item.get(&#34;closed_at&#34;),
                }
            elif search_type == &#34;commits&#34;:
                item_info = {
                    &#34;sha&#34;: item[&#34;sha&#34;],
                    &#34;commit_message&#34;: item[&#34;commit&#34;][&#34;message&#34;],
                    &#34;author&#34;: item[&#34;commit&#34;][&#34;author&#34;][&#34;name&#34;],
                    &#34;date&#34;: item[&#34;commit&#34;][&#34;author&#34;][&#34;date&#34;],
                    &#34;url&#34;: item[&#34;html_url&#34;],
                }
            elif search_type == &#34;topics&#34;:
                item_info = {
                    &#34;name&#34;: item[&#34;name&#34;],
                    &#34;display_name&#34;: item.get(&#34;display_name&#34;),
                    &#34;short_description&#34;: item.get(&#34;short_description&#34;),
                    &#34;description&#34;: item.get(&#34;description&#34;),
                    &#34;created_by&#34;: item.get(&#34;created_by&#34;),
                    &#34;url&#34;: item.get(&#34;url&#34;) if &#34;url&#34; in item else None,
                }

            result_list.append(item_info)

        return result_list

    except Exception as e:
        return self._handle_error(ValueError(f&#34;Unexpected error: {e}&#34;))</code></pre>
</details>
<div class="desc"><p>Searches GitHub for various types of content.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query</code></strong> :&ensp;<code>str</code></dt>
<dd>The search query.</dd>
<dt><strong><code>search_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>The type of search. Can be one of:
- "repositories"
- "users"
- "organizations"
- "issues"
- "pull_requests"
- "commits"
- "topics"</p>
<p>Defaults to "repositories".</p>
</dd>
<dt><strong><code>max_results</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number of results to return. Defaults to 3.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of search results or an error message.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.hindi_quote"><code class="name flex">
<span>async def <span class="ident">hindi_quote</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def hindi_quote(self) -&gt; str:
    &#34;&#34;&#34;
    Fetches a random Hindi quote.

    Returns:
        str: The content of a random Hindi quote.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;hindi_quote&#34;])
    response = response.json()
    return response[&#34;quote&#34;]</code></pre>
</details>
<div class="desc"><p>Fetches a random Hindi quote.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The content of a random Hindi quote.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.hug"><code class="name flex">
<span>async def <span class="ident">hug</span></span>(<span>self, amount: int = 1) ‑> list</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def hug(self, amount: int = 1) -&gt; list:
    &#34;&#34;&#34;Fetches a specified number hug gif from the Nekos.Best API.

    Args:
        amount (int): The number of neko images to fetch. Defaults to 1.

    Returns:
        list: A list of dictionaries containing information about each fetched neko image or GIF.
              Each dictionary typically includes:
              - anime_name (str): The name of the anime.
              - url (str): The URL of the GIF.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;neko_hug&#34;].format(amount))

    return response.json()[&#34;results&#34;]</code></pre>
</details>
<div class="desc"><p>Fetches a specified number hug gif from the Nekos.Best API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of neko images to fetch. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of dictionaries containing information about each fetched neko image or GIF.
Each dictionary typically includes:
- anime_name (str): The name of the anime.
- url (str): The URL of the GIF.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.meme"><code class="name flex">
<span>async def <span class="ident">meme</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def meme(self):
    &#34;&#34;&#34;
    Fetches a random meme image URL.

    Returns:
        str or None: The URL of the meme image if available, otherwise None.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;meme&#34;])
    response = response.json()
    return response[&#34;preview&#34;][-1] if response else None</code></pre>
</details>
<div class="desc"><p>Fetches a random meme image URL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>None</code></dt>
<dd>The URL of the meme image if available, otherwise None.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.neko"><code class="name flex">
<span>async def <span class="ident">neko</span></span>(<span>self, endpoint: str = 'neko', amount: int = 3) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def neko(self, endpoint: str = &#34;neko&#34;, amount: int = 3) -&gt; dict:
    &#34;&#34;&#34;Fetches a specified number of neko images or GIFs from the Nekos.Best API.

    Args:
        endpoint (str): The endpoint category to fetch content from. Default is &#34;neko&#34;.
            Valid image endpoints:
            - &#34;husbando&#34;, &#34;kitsune&#34;, &#34;neko&#34;, &#34;waifu&#34;
            Valid GIF endpoints:
            - &#34;baka&#34;, &#34;bite&#34;, &#34;blush&#34;, &#34;bored&#34;, &#34;cry&#34;, &#34;cuddle&#34;, &#34;dance&#34;, &#34;facepalm&#34;,
              &#34;feed&#34;, &#34;handhold&#34;, &#34;handshake&#34;, &#34;happy&#34;, &#34;highfive&#34;, &#34;hug&#34;, &#34;kick&#34;,
              &#34;kiss&#34;, &#34;laugh&#34;, &#34;lurk&#34;, &#34;nod&#34;, &#34;nom&#34;, &#34;nope&#34;, &#34;pat&#34;, &#34;peck&#34;, &#34;poke&#34;,
              &#34;pout&#34;, &#34;punch&#34;, &#34;shoot&#34;, &#34;shrug&#34;, &#34;slap&#34;, &#34;sleep&#34;, &#34;smile&#34;, &#34;smug&#34;,
              &#34;stare&#34;, &#34;think&#34;, &#34;thumbsup&#34;, &#34;tickle&#34;, &#34;wave&#34;, &#34;wink&#34;, &#34;yawn&#34;, &#34;yeet&#34;
        amount (int): The number of items to fetch. Default is 3.

    Returns:
        dict: A dictionary containing the results of the request. The dictionary has a key `&#34;results&#34;`,
              which holds a list of items.

    Raises:
        ValueError: If the endpoint is not a valid category.
    &#34;&#34;&#34;
    valid_categories = [
        &#34;husbando&#34;,
        &#34;kitsune&#34;,
        &#34;neko&#34;,
        &#34;waifu&#34;,  # Images
        &#34;baka&#34;,
        &#34;bite&#34;,
        &#34;blush&#34;,
        &#34;bored&#34;,
        &#34;cry&#34;,
        &#34;cuddle&#34;,
        &#34;dance&#34;,
        &#34;facepalm&#34;,
        &#34;feed&#34;,
        &#34;handhold&#34;,
        &#34;handshake&#34;,
        &#34;happy&#34;,
        &#34;highfive&#34;,
        &#34;hug&#34;,
        &#34;kick&#34;,
        &#34;kiss&#34;,
        &#34;laugh&#34;,
        &#34;lurk&#34;,
        &#34;nod&#34;,
        &#34;nom&#34;,
        &#34;nope&#34;,
        &#34;pat&#34;,
        &#34;peck&#34;,
        &#34;poke&#34;,
        &#34;pout&#34;,
        &#34;punch&#34;,
        &#34;shoot&#34;,
        &#34;shrug&#34;,
        &#34;slap&#34;,
        &#34;sleep&#34;,
        &#34;smile&#34;,
        &#34;smug&#34;,
        &#34;stare&#34;,
        &#34;think&#34;,
        &#34;thumbsup&#34;,
        &#34;tickle&#34;,
        &#34;wave&#34;,
        &#34;wink&#34;,
        &#34;yawn&#34;,
        &#34;yeet&#34;,  # GIFs
    ]

    if endpoint not in valid_categories:
        return self._handle_error(
            ValueError(
                f&#34;Invalid endpoint &#39;{endpoint}&#39;. Must be one of: {&#39;, &#39;.join(valid_categories)}&#34;
            )
        )

    url = self.base_urls[&#34;neko_url&#34;].format(endpoint=endpoint, amount=amount)

    response = await self.request.get(url)

    return response.json()</code></pre>
</details>
<div class="desc"><p>Fetches a specified number of neko images or GIFs from the Nekos.Best API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>endpoint</code></strong> :&ensp;<code>str</code></dt>
<dd>The endpoint category to fetch content from. Default is "neko".
Valid image endpoints:
- "husbando", "kitsune", "neko", "waifu"
Valid GIF endpoints:
- "baka", "bite", "blush", "bored", "cry", "cuddle", "dance", "facepalm",
"feed", "handhold", "handshake", "happy", "highfive", "hug", "kick",
"kiss", "laugh", "lurk", "nod", "nom", "nope", "pat", "peck", "poke",
"pout", "punch", "shoot", "shrug", "slap", "sleep", "smile", "smug",
"stare", "think", "thumbsup", "tickle", "wave", "wink", "yawn", "yeet"</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of items to fetch. Default is 3.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the results of the request. The dictionary has a key <code>"results"</code>,
which holds a list of items.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the endpoint is not a valid category.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.pypi"><code class="name flex">
<span>async def <span class="ident">pypi</span></span>(<span>self, package_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def pypi(self, package_name):
    &#34;&#34;&#34;
    Retrieves metadata information about a specified Python package from the PyPI API.

    Args:
        package_name (str): The name of the package to search for on PyPI.

    Returns:
        dict or None: A dictionary with relevant package information if found.
        Returns None if the package is not found or there is an error.
    &#34;&#34;&#34;
    url = f&#34;{self.base_urls[&#39;pypi&#39;]}/{package_name}/json&#34;
    response = await self.request.get(url)
    response = response.json()
    if response:
        return response
    else:
        return None</code></pre>
</details>
<div class="desc"><p>Retrieves metadata information about a specified Python package from the PyPI API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the package to search for on PyPI.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code> or <code>None</code></dt>
<dd>A dictionary with relevant package information if found.</dd>
</dl>
<p>Returns None if the package is not found or there is an error.</p></div>
</dd>
<dt id="TheApi.api.TheApi.quote"><code class="name flex">
<span>async def <span class="ident">quote</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def quote(self) -&gt; str:
    &#34;&#34;&#34;
    Fetches a random quote.

    Returns:
        str: The content of a random quote followed by the author&#39;s name.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;quote&#34;], verify=False)
    data = response.json()
    return f&#34;{data[&#39;content&#39;]}\n\nauthor - {data[&#39;author&#39;]}&#34;</code></pre>
</details>
<div class="desc"><p>Fetches a random quote.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The content of a random quote followed by the author's name.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.riddle"><code class="name flex">
<span>async def <span class="ident">riddle</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def riddle(self) -&gt; dict:
    &#34;&#34;&#34;
    Fetches a random riddle from the Riddles API.

    Returns:
        dict: The riddle data in JSON format.
    &#34;&#34;&#34;
    response = await self.request.get(self.base_urls[&#34;riddle&#34;])
    return response.json()</code></pre>
</details>
<div class="desc"><p>Fetches a random riddle from the Riddles API.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The riddle data in JSON format.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.stackoverflow_search"><code class="name flex">
<span>async def <span class="ident">stackoverflow_search</span></span>(<span>self, query, max_results=3, sort_type='relevance')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def stackoverflow_search(self, query, max_results=3, sort_type=&#34;relevance&#34;):
    &#34;&#34;&#34;
    Searches Stack Overflow for questions based on a query, returning results sorted by relevance or another specified criteria.

    Args:
        query (str): The search query string.
        max_results (int, optional): The maximum number of results to return. Defaults to 3.
        sort_type (str, optional): The sorting criteria for the results, such as &#34;relevance&#34; or &#34;votes&#34;. Defaults to &#34;relevance&#34;.

    Returns:
        list: A list of search results in JSON format, with each entry containing Stack Overflow question details.

    Raises:
        ValueError: If there is an issue with the request to the Stack Overflow API.
    &#34;&#34;&#34;

    url = &#34;https://api.stackexchange.com/2.3/search/advanced&#34;
    params = {
        &#34;order&#34;: &#34;desc&#34;,
        &#34;sort&#34;: sort_type,
        &#34;q&#34;: query,
        &#34;site&#34;: &#34;stackoverflow&#34;,
        &#34;page&#34;: 1,
    }

    all_results = []
    while len(all_results) &lt; max_results:
        response = await self.request.get(url, params=params)
        response = response.json()
        results = response.get(&#34;items&#34;, [])
        if not results:
            break

        all_results.extend(results)
        if len(results) &lt; 30:
            break

        params[&#34;page&#34;] += 1

    return all_results[:max_results]</code></pre>
</details>
<div class="desc"><p>Searches Stack Overflow for questions based on a query, returning results sorted by relevance or another specified criteria.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query</code></strong> :&ensp;<code>str</code></dt>
<dd>The search query string.</dd>
<dt><strong><code>max_results</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum number of results to return. Defaults to 3.</dd>
<dt><strong><code>sort_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The sorting criteria for the results, such as "relevance" or "votes". Defaults to "relevance".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of search results in JSON format, with each entry containing Stack Overflow question details.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If there is an issue with the request to the Stack Overflow API.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.upload_image"><code class="name flex">
<span>async def <span class="ident">upload_image</span></span>(<span>self, file_path: str | bytes | _io.BytesIO) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def upload_image(
    self, file_path: Union[str, bytes, BytesIO]
) -&gt; str:  # gh-actions Don&#39;t Add it&#39;s example, ignore it.
    &#34;&#34;&#34;
    Uploads an image to https://envs.sh.

    Args:
        file_path (Union[str, bytes, BytesIO]): The image file to upload.
            Can be a file path (str), binary data (bytes), or a BytesIO object.

    Returns:
        str: The URL or confirmation message of the uploaded image if the upload is successful.
            Returns &#34;Unexpected response format&#34; if the response format is not as expected.

    Raises:
        ValueError: If the file is not found, the input type is invalid,
            or the upload request fails.
    &#34;&#34;&#34;
    if isinstance(file_path, str):
        try:
            async with aiofiles.open(file_path, &#34;rb&#34;) as f:
                image_bytes = await f.read()
        except FileNotFoundError:
            return self._handle_error(
                ValueError(
                    f&#34;File not found: &#39;{file_path}&#39; - Ensure the file path is correct.&#34;
                )
            )
    elif isinstance(file_path, bytes) or isinstance(file_path, BytesIO):
        image_bytes = (
            file_path if isinstance(file_path, bytes) else file_path.getvalue()
        )
    else:
        return self._handle_error(
            ValueError(
                &#34;Invalid input type - Expected a file path (str), binary data (bytes), or BytesIO object.&#34;
            )
        )

    url = self.base_urls[&#34;upload&#34;]
    files = {&#34;file&#34;: image_bytes}

    try:
        response = await self.request.post(url=url, files=files)
        return (
            response.text.strip()
            if isinstance(response, str)
            else &#34;Unexpected response format&#34;
        )
    except ValueError as e:
        return self._handle_error(ValueError(f&#34;Upload failed: {str(e)}&#34;))</code></pre>
</details>
<div class="desc"><p>Uploads an image to <a href="https://envs.sh.">https://envs.sh.</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>Union[str, bytes, BytesIO]</code></dt>
<dd>The image file to upload.
Can be a file path (str), binary data (bytes), or a BytesIO object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The URL or confirmation message of the uploaded image if the upload is successful.
Returns "Unexpected response format" if the response format is not as expected.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the file is not found, the input type is invalid,
or the upload request fails.</dd>
</dl></div>
</dd>
<dt id="TheApi.api.TheApi.wikipedia"><code class="name flex">
<span>async def <span class="ident">wikipedia</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wikipedia(self, query):
    &#34;&#34;&#34;
    Searches Wikipedia for a given query and retrieves the top result&#39;s summary, URL, and image.

    Args:
        query (str): The search term to look up on Wikipedia.

    Returns:
        dict: A dictionary containing information about the top search result, with keys:
            - title (str): The title of the Wikipedia article.
            - summary (str): A brief summary of the article&#39;s content.
            - url (str): The URL link to the full Wikipedia article.
            - image_url (str): The URL of the article&#39;s thumbnail image, or &#34;No image available&#34; if none exists.

        If no results are found, returns a dictionary with an &#34;error&#34; key.
    &#34;&#34;&#34;
    search_url = self.base_urls[&#34;wikipedia_search&#34;]

    params = {
        &#34;action&#34;: &#34;query&#34;,
        &#34;list&#34;: &#34;search&#34;,
        &#34;srsearch&#34;: query,
        &#34;format&#34;: &#34;json&#34;,
    }

    search_response = await self.request.get(search_url, params=params)
    search_response = search_response.json()
    search_results = search_response.get(&#34;query&#34;, {}).get(&#34;search&#34;, [])

    if search_results:
        top_result = search_results[0]
        page_id = top_result[&#34;pageid&#34;]
        summary_url = (
            f&#34;{self.base_urls[&#39;wikipedia_search&#39;]}?action=query&amp;prop=extracts|pageimages&#34;
            f&#34;&amp;exintro&amp;explaintext&amp;piprop=thumbnail&amp;pithumbsize=500&amp;format=json&amp;pageids={page_id}&#34;
        )

        summary_response = await self.request.get(summary_url)
        summary_response = summary_response.json()
        pages = summary_response.get(&#34;query&#34;, {}).get(&#34;pages&#34;, {})
        page_info = pages.get(str(page_id), {})
        image_url = page_info.get(&#34;thumbnail&#34;, {}).get(
            &#34;source&#34;, &#34;No image available&#34;
        )

        return {
            &#34;title&#34;: top_result[&#34;title&#34;],
            &#34;summary&#34;: page_info.get(&#34;extract&#34;, &#34;No summary available.&#34;),
            &#34;url&#34;: f&#34;https://en.wikipedia.org/?curid={page_id}&#34;,
            &#34;image_url&#34;: image_url,
        }
    else:
        return self._handle_error(ValueError(&#34;No search results found&#34;))</code></pre>
</details>
<div class="desc"><p>Searches Wikipedia for a given query and retrieves the top result's summary, URL, and image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query</code></strong> :&ensp;<code>str</code></dt>
<dd>The search term to look up on Wikipedia.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing information about the top search result, with keys:
- title (str): The title of the Wikipedia article.
- summary (str): A brief summary of the article's content.
- url (str): The URL link to the full Wikipedia article.
- image_url (str): The URL of the article's thumbnail image, or "No image available" if none exists.</dd>
</dl>
<p>If no results are found, returns a dictionary with an "error" key.</p></div>
</dd>
<dt id="TheApi.api.TheApi.write"><code class="name flex">
<span>async def <span class="ident">write</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def write(self, text):
    &#34;&#34;&#34;
    Creates an image with text written on it, using a predefined template and font,
    and uploads the image after generation.

    Args:
        text (str): The text to be written on the image. Text exceeding 55 characters
                    per line will be wrapped, with up to 25 lines displayed.

    Returns:
        str: The URL of the uploaded image.

    Notes:
        A temporary image file is created, saved, and removed after uploading.
    &#34;&#34;&#34;
    tryimg = &#34;https://graph.org/file/1f8d00177ac2429b101b9.jpg&#34;
    tryresp = await self.request.get(tryimg)
    img = Image.open(BytesIO(tryresp.content))
    draw = ImageDraw.Draw(img)

    font_url = &#34;https://github.com/google/fonts/raw/main/ofl/poetsenone/PoetsenOne-Regular.ttf&#34;
    font_response = await self.request.get(font_url)
    font = ImageFont.truetype(BytesIO(font_response.content), 24)

    x, y = 150, 140
    lines = []
    if len(text) &lt;= 55:
        lines.append(text)
    else:
        all_lines = text.split(&#34;\n&#34;)
        for line in all_lines:
            if len(line) &lt;= 55:
                lines.append(line)
            else:
                k = len(line) // 55
                lines.extend(
                    line[((z - 1) * 55) : (z * 55)] for z in range(1, k + 2)
                )

    umm = lines[:25]

    line_height = font.getbbox(&#34;hg&#34;)[3]
    linespacing = 41
    for line in umm:
        draw.text((x, y), line, fill=(1, 22, 55), font=font)
        y = y + linespacing

    file_path = os.path.join(self.downloads_dir, f&#34;write_{self._rnd_str()}.jpg&#34;)

    img.save(file_path)

    return file_path</code></pre>
</details>
<div class="desc"><p>Creates an image with text written on it, using a predefined template and font,
and uploads the image after generation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to be written on the image. Text exceeding 55 characters
per line will be wrapped, with up to 25 lines displayed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The URL of the uploaded image.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>A temporary image file is created, saved, and removed after uploading.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="TheApi" href="index.html">TheApi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="TheApi.api.TheApi" href="#TheApi.api.TheApi">TheApi</a></code></h4>
<ul class="">
<li><code><a title="TheApi.api.TheApi.animechan" href="#TheApi.api.TheApi.animechan">animechan</a></code></li>
<li><code><a title="TheApi.api.TheApi.avatar" href="#TheApi.api.TheApi.avatar">avatar</a></code></li>
<li><code><a title="TheApi.api.TheApi.bing_image" href="#TheApi.api.TheApi.bing_image">bing_image</a></code></li>
<li><code><a title="TheApi.api.TheApi.blackpink" href="#TheApi.api.TheApi.blackpink">blackpink</a></code></li>
<li><code><a title="TheApi.api.TheApi.carbon" href="#TheApi.api.TheApi.carbon">carbon</a></code></li>
<li><code><a title="TheApi.api.TheApi.cat" href="#TheApi.api.TheApi.cat">cat</a></code></li>
<li><code><a title="TheApi.api.TheApi.dog" href="#TheApi.api.TheApi.dog">dog</a></code></li>
<li><code><a title="TheApi.api.TheApi.domain_search" href="#TheApi.api.TheApi.domain_search">domain_search</a></code></li>
<li><code><a title="TheApi.api.TheApi.fakerapi" href="#TheApi.api.TheApi.fakerapi">fakerapi</a></code></li>
<li><code><a title="TheApi.api.TheApi.fox" href="#TheApi.api.TheApi.fox">fox</a></code></li>
<li><code><a title="TheApi.api.TheApi.gen_qr" href="#TheApi.api.TheApi.gen_qr">gen_qr</a></code></li>
<li><code><a title="TheApi.api.TheApi.generate_pdf" href="#TheApi.api.TheApi.generate_pdf">generate_pdf</a></code></li>
<li><code><a title="TheApi.api.TheApi.get_advice" href="#TheApi.api.TheApi.get_advice">get_advice</a></code></li>
<li><code><a title="TheApi.api.TheApi.get_btc_value" href="#TheApi.api.TheApi.get_btc_value">get_btc_value</a></code></li>
<li><code><a title="TheApi.api.TheApi.get_fake_addresses" href="#TheApi.api.TheApi.get_fake_addresses">get_fake_addresses</a></code></li>
<li><code><a title="TheApi.api.TheApi.get_fake_credit_cards" href="#TheApi.api.TheApi.get_fake_credit_cards">get_fake_credit_cards</a></code></li>
<li><code><a title="TheApi.api.TheApi.get_fake_images" href="#TheApi.api.TheApi.get_fake_images">get_fake_images</a></code></li>
<li><code><a title="TheApi.api.TheApi.get_hindi_jokes" href="#TheApi.api.TheApi.get_hindi_jokes">get_hindi_jokes</a></code></li>
<li><code><a title="TheApi.api.TheApi.get_jokes" href="#TheApi.api.TheApi.get_jokes">get_jokes</a></code></li>
<li><code><a title="TheApi.api.TheApi.get_uselessfact" href="#TheApi.api.TheApi.get_uselessfact">get_uselessfact</a></code></li>
<li><code><a title="TheApi.api.TheApi.get_word_definitions" href="#TheApi.api.TheApi.get_word_definitions">get_word_definitions</a></code></li>
<li><code><a title="TheApi.api.TheApi.get_words" href="#TheApi.api.TheApi.get_words">get_words</a></code></li>
<li><code><a title="TheApi.api.TheApi.github_search" href="#TheApi.api.TheApi.github_search">github_search</a></code></li>
<li><code><a title="TheApi.api.TheApi.hindi_quote" href="#TheApi.api.TheApi.hindi_quote">hindi_quote</a></code></li>
<li><code><a title="TheApi.api.TheApi.hug" href="#TheApi.api.TheApi.hug">hug</a></code></li>
<li><code><a title="TheApi.api.TheApi.meme" href="#TheApi.api.TheApi.meme">meme</a></code></li>
<li><code><a title="TheApi.api.TheApi.neko" href="#TheApi.api.TheApi.neko">neko</a></code></li>
<li><code><a title="TheApi.api.TheApi.pypi" href="#TheApi.api.TheApi.pypi">pypi</a></code></li>
<li><code><a title="TheApi.api.TheApi.quote" href="#TheApi.api.TheApi.quote">quote</a></code></li>
<li><code><a title="TheApi.api.TheApi.riddle" href="#TheApi.api.TheApi.riddle">riddle</a></code></li>
<li><code><a title="TheApi.api.TheApi.stackoverflow_search" href="#TheApi.api.TheApi.stackoverflow_search">stackoverflow_search</a></code></li>
<li><code><a title="TheApi.api.TheApi.upload_image" href="#TheApi.api.TheApi.upload_image">upload_image</a></code></li>
<li><code><a title="TheApi.api.TheApi.wikipedia" href="#TheApi.api.TheApi.wikipedia">wikipedia</a></code></li>
<li><code><a title="TheApi.api.TheApi.write" href="#TheApi.api.TheApi.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
